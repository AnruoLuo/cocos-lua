local olua = require "olua.olua-io"

local format = olua.format

local function genConvHeader(module)
    local HEADER = string.upper(module.NAME)
    local DECL_FUNCS = {}

    for _, cv in ipairs(module.CONVS) do
        DECL_FUNCS[#DECL_FUNCS + 1] = "// " .. cv.CPPCLS
        local CPPCLS_PATH = olua.topath(cv.CPPCLS)
        DECL_FUNCS[#DECL_FUNCS + 1] = format([[
            int auto_olua_push_${CPPCLS_PATH}(lua_State *L, const ${cv.CPPCLS} *value);
            void auto_olua_check_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value);
            void auto_olua_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value, const ${cv.CPPCLS} &def);
            bool auto_olua_is_${CPPCLS_PATH}(lua_State *L, int idx);
        ]])
        if cv.FUNC.PACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                void auto_olua_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value);
                int auto_olua_unpack_${CPPCLS_PATH}(lua_State *L, const ${cv.CPPCLS} *value);
            ]])
        end
        if cv.FUNC.ISPACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                bool auto_olua_ispack_${CPPCLS_PATH}(lua_State *L, int idx);
            ]])
        end
        DECL_FUNCS[#DECL_FUNCS + 1] = ""
        olua.nowarning(CPPCLS_PATH)
    end

    DECL_FUNCS = table.concat(DECL_FUNCS, "\n")

    local HEADER_INCLUDES = module.HEADER_INCLUDES
    olua.write(module.HEADER_PATH, format([[
        //
        // generated by olua
        //
        #ifndef __AUTO_GEN_LUA_${HEADER}_H__
        #define __AUTO_GEN_LUA_${HEADER}_H__

        ${HEADER_INCLUDES}

        ${DECL_FUNCS}

        #endif
    ]]))
    olua.nowarning(HEADER, HEADER_INCLUDES)
end

local function getinitvalue(ti)
    if olua.isvaluetype(ti) then
        if ti.DECLTYPE == 'lua_Number'
            or ti.DECLTYPE == 'lua_Integer'
            or ti.DECLTYPE == 'lua_Unsigned' then
            return '0'
        elseif ti.DECLTYPE == 'std::string' then
            return '""'
        elseif ti.DECLTYPE == 'bool' then
            return 'false'
        elseif ti.DECLTYPE == 'const char *' then
            return 'nullptr'
        else
            error('unknown type:' .. ti.TYPE.CPPCLS)
        end
    elseif string.find(ti.CPPCLS, '[*]') then
        return 'nullptr'
    else
        return ti.CPPCLS .. '()'
    end
end

local function genPushFunc(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {""}

    for _, pi in ipairs(cv.PROPS) do
        local OLUA_PUSH_VALUE = olua.convfunc(pi.TYPE, 'push')
        if olua.isvaluetype(pi.TYPE) then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_PUSH_VALUE}(L, (${pi.TYPE.DECLTYPE})value->${pi.VARNAME});
                olua_setfield(L, -2, "${pi.LUANAME}");
            ]])
        elseif pi.TYPE.LUACLS then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_PUSH_VALUE}(L, value->${pi.VARNAME}, "${pi.TYPE.LUACLS}"");
                olua_setfield(L, -2, "${pi.LUANAME}");
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_PUSH_VALUE}(L, &value->${pi.VARNAME});
                olua_setfield(L, -2, "${pi.LUANAME}");
            ]])
        end
        ARGS_CHUNK[#ARGS_CHUNK + 1] = ""
        olua.nowarning(OLUA_PUSH_VALUE)
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        int auto_olua_push_${CPPCLS_PATH}(lua_State *L, const ${cv.CPPCLS} *value)
        {
            if (value) {
                lua_createtable(L, 0, ${NUM_ARGS});
                ${ARGS_CHUNK}
            } else {
                lua_pushnil(L);
            }
            
            return 1;
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH, NUM_ARGS)
end

local function gen_check_func(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local DECL_ARGS = olua.newarray()
    local CHECK_ARGS = olua.newarray()
    for i, pi in ipairs(cv.PROPS) do
        local OLUA_CHECK_VALUE = olua.convfunc(pi.TYPE, 'check')
        local ARG_NAME = 'arg' .. i

        if pi.TYPE.SUBTYPE then
            -- ai.DECLTYPE = std::vector<std::string>
            -- ai.TYPE.DECLTYPE = std::vector
            DECL_ARGS:push(format([[
                ${pi.DECLTYPE} ${ARG_NAME};       /** ${pi.VARNAME} */
            ]]))
        else
            DECL_ARGS:push(format([[
                ${pi.TYPE.DECLTYPE} ${ARG_NAME};       /** ${pi.VARNAME} */
            ]]))
        end

        CHECK_ARGS:push(format([[
            olua_getfield(L, idx, "${pi.LUANAME}");
        ]]))

        if pi.DEFAULT then
            local OLUA_OPT_VALUE = olua.convfunc(pi.TYPE, 'opt')
            local DEFAULT = pi.DEFAULT
            olua.nowarning(OLUA_OPT_VALUE, DEFAULT)
            if pi.TYPE.LUACLS and not olua.isvaluetype(pi.TYPE) then
                pi.CHECK_ARGS:push(format([[
                    ${OLUA_OPT_VALUE}(L, -1, (void **)&${ARG_NAME}, "${pi.TYPE.LUACLS}", ${pi.DEFAULT});
                ]]))
            else
                CHECK_ARGS:push(format([[
                    ${OLUA_OPT_VALUE}(L, -1, &${ARG_NAME}, (${pi.TYPE.DECLTYPE})${DEFAULT});
                ]]))
            end
        else
            if pi.TYPE.LUACLS and not olua.isvaluetype(pi.TYPE) then
                CHECK_ARGS:push(format([[
                    ${OLUA_CHECK_VALUE}(L, -1, (void **)&${ARG_NAME}, "${pi.TYPE.LUACLS}");
                ]]))
            else
                CHECK_ARGS:push(format([[
                    ${OLUA_CHECK_VALUE}(L, -1, &${ARG_NAME});
                ]]))
            end
        end
        CHECK_ARGS:push(format([[
            value->${pi.VARNAME} = (${pi.TYPE.CPPCLS})${ARG_NAME};
            lua_pop(L, 1);
        ]]))
        CHECK_ARGS:push('')
        olua.nowarning(ARG_NAME, OLUA_CHECK_VALUE)
    end

    DECL_ARGS = table.concat(DECL_ARGS, "\n")
    CHECK_ARGS = table.concat(CHECK_ARGS, "\n")
    write(format([[
        void auto_olua_check_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            luaL_checktype(L, idx, LUA_TTABLE);

            ${DECL_ARGS}

            ${CHECK_ARGS}
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH)
end

local function gen_opt_func(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local DECL_ARGS = olua.newarray()
    local CHECK_ARGS = olua.newarray()
    for i, pi in ipairs(cv.PROPS) do
        local ARG_NAME = 'arg' .. i
        local INIT_VALUE = pi.DEFAULT or getinitvalue(pi.TYPE)
        local OLUA_OPT_VALUE = olua.convfunc(pi.TYPE, 'opt')

        if pi.TYPE.SUBTYPE then
            -- ai.DECLTYPE = std::vector<std::string>
            -- ai.TYPE.DECLTYPE = std::vector
            DECL_ARGS:push(format([[
                ${pi.DECLTYPE} ${ARG_NAME};       /** ${pi.VARNAME} */
            ]]))
        else
            DECL_ARGS:push(format([[
                ${pi.TYPE.DECLTYPE} ${ARG_NAME};       /** ${pi.VARNAME} */
            ]]))
        end

        CHECK_ARGS:push(format([[
            olua_getfield(L, idx, "${pi.LUANAME}");
        ]]))

        if pi.TYPE.LUACLS and not olua.isvaluetype(pi.TYPE) then
            pi.CHECK_ARGS:push(format([[
                ${OLUA_OPT_VALUE}(L, -1, (void **)&${ARG_NAME}, "${pi.TYPE.LUACLS}", ${INIT_VALUE});
            ]]))
        else
            CHECK_ARGS:push(format([[
                ${OLUA_OPT_VALUE}(L, -1, &${ARG_NAME}, (${pi.TYPE.DECLTYPE})${INIT_VALUE});
            ]]))
        end

        CHECK_ARGS:push(format([[
            value->${pi.VARNAME} = (${pi.TYPE.CPPCLS})${ARG_NAME};
            lua_pop(L, 1);
        ]]))
        CHECK_ARGS:push('')

        olua.nowarning(ARG_NAME, INIT_VALUE, OLUA_OPT_VALUE)
    end

    DECL_ARGS = table.concat(DECL_ARGS, "\n")
    CHECK_ARGS = table.concat(CHECK_ARGS, "\n")
    write(format([[
        void auto_olua_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value, const ${cv.CPPCLS} &def)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            if (olua_isnil(L, idx)) {
                *value = def;
            } else {
                idx = lua_absindex(L, idx);
                luaL_checktype(L, idx, LUA_TTABLE);

                ${DECL_ARGS}

                ${CHECK_ARGS}
            }
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH)
end

local function gen_pack_func(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local ARGS_CHUNK = {}

    for i, pi in ipairs(cv.PROPS) do
        local ARG_N = i - 1
        local OLUA_PACK_VALUE = olua.convfunc(pi.TYPE, 'check')
        OLUA_PACK_VALUE = string.gsub(OLUA_PACK_VALUE, '_check_', '_check')
        ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
            value->${pi.VARNAME} = (${pi.TYPE.CPPCLS})${OLUA_PACK_VALUE}(L, idx + ${ARG_N});
        ]])
        olua.nowarning(ARG_N)
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        void auto_olua_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${cv.CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            ${ARGS_CHUNK}
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH)
end

local function genUnpackFunc(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local OLUA_UNPACK_VALUE = olua.convfunc(pi.TYPE, 'push')
        if pi.TYPE.LUACLS and not olua.isvaluetype(pi.TYPE) then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_UNPACK_VALUE}(L, value->${pi.VARNAME}, "${pi.TYPE.LUACLS}");
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_UNPACK_VALUE}(L, (${pi.TYPE.DECLTYPE})value->${pi.VARNAME});
            ]])
        end
        olua.nowarning(OLUA_UNPACK_VALUE)
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        int auto_olua_unpack_${CPPCLS_PATH}(lua_State *L, const ${cv.CPPCLS} *value)
        {
            if (value) {
                ${ARGS_CHUNK}
            } else {
                for (int i = 0; i < ${NUM_ARGS}; i++) {
                    lua_pushnil(L);
                }
            }
            
            return ${NUM_ARGS};
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH, NUM_ARGS)
end

local function genIsFunc(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local TEST_HAS = {'olua_istable(L, idx)'}
    for _, pi in ipairs(cv.PROPS) do
        if not pi.DEFAULT then
            table.insert(TEST_HAS, 2, format([[
                olua_hasfield(L, idx, "${pi.LUANAME}")
            ]]))
        end
    end
    TEST_HAS = table.concat(TEST_HAS, " && ")
    write(format([[
        bool auto_olua_is_${CPPCLS_PATH}(lua_State *L, int idx)
        {
            return ${TEST_HAS};
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH)
end

local function genIsPackFunc(cv, write)
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local TEST_TYPE = {}
    for i, pi in ipairs(cv.PROPS) do
        local OLUA_IS_VALUE = olua.convfunc(pi.TYPE, 'is')
        local VIDX = i - 1
        TEST_TYPE[#TEST_TYPE + 1] = format([[
            ${OLUA_IS_VALUE}(L, idx + ${VIDX})
        ]])
        olua.nowarning(OLUA_IS_VALUE, VIDX)
    end
    TEST_TYPE = table.concat(TEST_TYPE, " && ")
    write(format([[
        bool auto_olua_ispack_${CPPCLS_PATH}(lua_State *L, int idx)
        {
            return ${TEST_TYPE};
        }
    ]]))
    write('')
    olua.nowarning(CPPCLS_PATH)
end

local function genFuncs(cv, write)
    genPushFunc(cv, write)
    gen_check_func(cv, write)
    gen_opt_func(cv, write)
    genIsFunc(cv, write)

    if cv.FUNC.PACK then
        gen_pack_func(cv, write)
    end
    if cv.FUNC.UNPACK then
        genUnpackFunc(cv, write)
    end
    if cv.FUNC.ISPACK then
        genIsPackFunc(cv, write)
    end
end

local function genConvSource(module)
    local arr = {}
    local function append(value)
        arr[#arr + 1] = value
    end

    append(format([[
        //
        // generated by olua
        //
        ${module.INCLUDES}
    ]]))
    append('')

    for _, cv in ipairs(module.CONVS) do
        genFuncs(cv, append)
    end

    olua.write(module.SOURCE_PATH, table.concat(arr, "\n"))
end

function olua.genconv(module, write)
    if write then
        for _, cv in ipairs(module.CONVS) do
            genFuncs(cv, write)
        end
    else
        genConvHeader(module)
        genConvSource(module)
    end
end