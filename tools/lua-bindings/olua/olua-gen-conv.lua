local olua = require "olua.olua-io"

local format = olua.format

local function gen_conv_header(module)
    local HEADER = string.upper(module.NAME)
    local DECL_FUNCS = {}

    for _, cv in ipairs(module.CONVS) do
        DECL_FUNCS[#DECL_FUNCS + 1] = "// " .. cv.CPPCLS
        local CPPCLS = cv.CPPCLS
        local CPPCLS_PATH = olua.topath(cv.CPPCLS)
        if cv.FUNC.PUSH then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                int auto_olua_push_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.CHECK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                void auto_olua_check_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.OPT then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                void auto_olua_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value, const ${CPPCLS} &def);
            ]])
        end
        if cv.FUNC.PACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                void auto_olua_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.UNPACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                int auto_olua_unpack_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.IS then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                bool auto_olua_is_${CPPCLS_PATH}(lua_State *L, int idx);
            ]])
        end
        if cv.FUNC.ISPACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format([[
                bool auto_olua_ispack_${CPPCLS_PATH}(lua_State *L, int idx);
            ]])
        end
        DECL_FUNCS[#DECL_FUNCS + 1] = ""
    end

    DECL_FUNCS = table.concat(DECL_FUNCS, "\n")

    local HEADER_INCLUDES = module.HEADER_INCLUDES
    olua.write(module.HEADER_PATH, format([[
        //
        // generated by olua
        //
        #ifndef __AUTO_GEN_LUA_${HEADER}_H__
        #define __AUTO_GEN_LUA_${HEADER}_H__

        ${HEADER_INCLUDES}

        ${DECL_FUNCS}

        #endif
    ]]))
end

local function gen_push_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local OLUA_PUSH_VALUE
        local isbase = true
        local DECLTYPE = ""
        if pi.TYPE.DECLTYPE == 'lua_Number' then
            OLUA_PUSH_VALUE = 'olua_setfieldnumber'
        elseif pi.TYPE.DECLTYPE == 'lua_Integer'
            or pi.TYPE.DECLTYPE == 'lua_Unsigned' then
            OLUA_PUSH_VALUE = 'olua_setfieldinteger'
            DECLTYPE = '(' .. pi.TYPE.DECLTYPE .. ')'
        elseif pi.TYPE.CPPCLS == 'std::string' then
            OLUA_PUSH_VALUE = 'olua_setfieldstring'
            VARNAME = VARNAME .. '.c_str()'
        elseif pi.TYPE.CPPCLS == 'bool' then
            OLUA_PUSH_VALUE = 'olua_setfieldboolean'
        elseif pi.TYPE.CPPCLS == 'const char *' then
            OLUA_PUSH_VALUE = 'olua_setfieldstring'
        else
            isbase = false
            OLUA_PUSH_VALUE = olua.convfunc(pi.TYPE, 'push')
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.CPPCLS))
        end
        if isbase then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_PUSH_VALUE}(L, -1, "${LUANAME}", ${DECLTYPE}value->${VARNAME});
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                ${OLUA_PUSH_VALUE}(L, &value->${VARNAME});
                lua_setfield(L, -2, "${LUANAME}");
            ]])
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        int auto_olua_push_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value)
        {
            if (value) {
                lua_createtable(L, 0, ${NUM_ARGS});
                ${ARGS_CHUNK}
            } else {
                lua_pushnil(L);
            }
            
            return 1;
        }
    ]]))
    write('')
end

local function gen_check_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local CPPCLS = pi.TYPE.CPPCLS
        local OLUA_CHECK_VALUE
        local isbase = true
        local INIT_VALUE = pi.TYPE.INIT_VALUE
        if pi.TYPE.DECLTYPE == 'lua_Number' then
            OLUA_CHECK_VALUE = 'olua_checkfieldnumber'
        elseif pi.TYPE.DECLTYPE == 'lua_Integer'
            or pi.TYPE.DECLTYPE == 'lua_Unsigned' then
            OLUA_CHECK_VALUE = 'olua_checkfieldinteger'
        elseif pi.TYPE.CPPCLS == 'std::string' then
            OLUA_CHECK_VALUE = 'olua_checkfieldstring'
        elseif pi.TYPE.CPPCLS == 'bool' then
            OLUA_CHECK_VALUE = 'olua_checkfieldboolean'
        elseif pi.TYPE.CPPCLS == 'const char *' then
            OLUA_CHECK_VALUE = 'olua_checkfieldstring'
        else
            OLUA_CHECK_VALUE = olua.convfunc(pi.TYPE, 'check')
            isbase = false
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.CPPCLS))
        end
        if pi.DEFAULT then
            local DEFAULT = pi.DEFAULT
            OLUA_CHECK_VALUE = string.gsub(OLUA_CHECK_VALUE, '_check', '_opt')
            if isbase then
                ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                    value->${VARNAME} = (${CPPCLS})${OLUA_CHECK_VALUE}(L, idx, "${LUANAME}", ${DEFAULT});
                ]])
            else
                ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                    lua_getfield(L, -1, "${LUANAME}");
                    ${OLUA_CHECK_VALUE}(L, idx, &value->${VARNAME});
                    lua_pop(L, 1);
                ]])
            end
        else
            if isbase then
                ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                    value->${VARNAME} = (${CPPCLS})${OLUA_CHECK_VALUE}(L, idx, "${LUANAME}");
                ]])
            else
                ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                    lua_getfield(L, -1, "${LUANAME}");
                    ${OLUA_CHECK_VALUE}(L, idx, &value->${VARNAME});
                    lua_pop(L, 1);
                ]])
            end
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        void auto_olua_check_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            luaL_checktype(L, idx, LUA_TTABLE);
            ${ARGS_CHUNK}
        }
    ]]))
    write('')
end

local function gen_opt_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local CPPCLS = pi.TYPE.CPPCLS
        local OLUA_OPT_VALUE
        local isbase = true
        local INIT_VALUE = pi.TYPE.INIT_VALUE
        if pi.TYPE.DECLTYPE == 'lua_Number' then
            OLUA_OPT_VALUE = 'olua_optfieldnumber'
        elseif pi.TYPE.DECLTYPE == 'lua_Integer'
            or pi.TYPE.DECLTYPE == 'lua_Unsigned' then
            OLUA_OPT_VALUE = 'olua_optfieldinteger'
        elseif pi.TYPE.CPPCLS == 'std::string' then
            OLUA_OPT_VALUE = 'olua_optfieldstring'
            INIT_VALUE = '""'
        elseif pi.TYPE.CPPCLS == 'bool' then
            OLUA_OPT_VALUE = 'olua_optfieldboolean'
        elseif pi.TYPE.CPPCLS == 'const char *' then
            OLUA_OPT_VALUE = 'olua_optfieldstring'
        else
            OLUA_OPT_VALUE = olua.convfunc(pi.TYPE, 'check')
            isbase = false
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.CPPCLS))
        end
        if isbase then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                value->${VARNAME} = (${CPPCLS})${OLUA_OPT_VALUE}(L, idx, "${LUANAME}", ${INIT_VALUE});
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
                lua_getfield(L, -1, "${LUANAME}");
                ${OLUA_OPT_VALUE}(L, idx, &value->${VARNAME});
                lua_pop(L, 1);
            ]])
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        void auto_olua_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value, const ${CPPCLS} &def)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            if (olua_isnil(L, idx)) {
                *value = def;
            } else {
                idx = lua_absindex(L, idx);
                luaL_checktype(L, idx, LUA_TTABLE);
                ${ARGS_CHUNK}
            }
        }
    ]]))
    write('')
end

local function gen_pack_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for i, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local CPPCLS = pi.TYPE.CPPCLS
        local ARG_N = i - 1
        local OLUA_PACK_VALUE
        if pi.TYPE.DECLTYPE == 'lua_Number' then
            OLUA_PACK_VALUE = 'olua_checknumber'
        elseif pi.TYPE.DECLTYPE == 'lua_Integer'
            or pi.TYPE.DECLTYPE == 'lua_Unsigned' then
            OLUA_PACK_VALUE = 'olua_checkinteger'
        elseif pi.TYPE.CPPCLS == 'std::string' then
            OLUA_PACK_VALUE = 'olua_checkstring'
        elseif pi.TYPE.CPPCLS == 'bool' then
            OLUA_PACK_VALUE = 'olua_checktoboolean'
        elseif pi.TYPE.CPPCLS == 'const char *' then
            OLUA_PACK_VALUE = 'olua_checkstring'
        else
            error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.CPPCLS))
        end
        ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
            value->${VARNAME} = (${CPPCLS})${OLUA_PACK_VALUE}(L, idx + ${ARG_N});
        ]])
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        void auto_olua_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            ${ARGS_CHUNK}
        }
    ]]))
    write('')
end

local function gen_unpack_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for i, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local CPPCLS = pi.TYPE.CPPCLS
        local ARG_N = i - 1
        local OLUA_UNPACK_VALUE
        if pi.TYPE.DECLTYPE == 'lua_Number' then
            OLUA_UNPACK_VALUE = 'lua_pushnumber'
        elseif pi.TYPE.DECLTYPE == 'lua_Integer'
            or pi.TYPE.DECLTYPE == 'lua_Unsigned' then
            OLUA_UNPACK_VALUE = 'lua_pushinteger'
        elseif pi.TYPE.CPPCLS == 'std::string' then
            OLUA_UNPACK_VALUE = 'lua_pushstring'
            VARNAME = VARNAME .. '.c_str()'
        elseif pi.TYPE.CPPCLS == 'bool' then
            OLUA_UNPACK_VALUE = 'lua_pushboolean'
        elseif pi.TYPE.CPPCLS == 'const char *' then
            OLUA_UNPACK_VALUE = 'lua_pushstring'
        else
            error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.CPPCLS))
        end
        ARGS_CHUNK[#ARGS_CHUNK + 1] = format([[
            ${OLUA_UNPACK_VALUE}(L, value->${VARNAME});
        ]])
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format([[
        int auto_olua_unpack_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value)
        {
            if (value) {
                ${ARGS_CHUNK}
            } else {
                for (int i = 0; i < ${NUM_ARGS}; i++) {
                    lua_pushnil(L);
                }
            }
            
            return ${NUM_ARGS};
        }
    ]]))
    write('')
end

local function gen_is_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local TEST_HAS = {'olua_istable(L, idx)'}
    for i, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        table.insert(TEST_HAS, 2, format([[
            olua_hasfield(L, idx, "${LUANAME}")
        ]]))
    end
    TEST_HAS = table.concat(TEST_HAS, " && ")
    write(format([[
        bool auto_olua_is_${CPPCLS_PATH}(lua_State *L, int idx)
        {
            return ${TEST_HAS};
        }
    ]]))
    write('')
end

local function gen_ispack_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = olua.topath(cv.CPPCLS)
    local TEST_TYPE = {}
    for i, pi in ipairs(cv.PROPS) do
        local OLUA_IS_VALUE = olua.convfunc(pi.TYPE, 'is')
        local VIDX = i - 1
        TEST_TYPE[#TEST_TYPE + 1] = format([[
            ${OLUA_IS_VALUE}(L, idx + ${VIDX})
        ]])
    end
    TEST_TYPE = table.concat(TEST_TYPE, " && ")
    write(format([[
        bool auto_olua_ispack_${CPPCLS_PATH}(lua_State *L, int idx)
        {
            return ${TEST_TYPE};
        }
    ]]))
    write('')
end

local function gen_funcs(cv, write)
    if cv.FUNC.PUSH then
        gen_push_func(cv, write)
    end
    if cv.FUNC.CHECK then
        gen_check_func(cv, write)
    end
    if cv.FUNC.OPT then
        gen_opt_func(cv, write)
    end
    if cv.FUNC.PACK then
        gen_pack_func(cv, write)
    end
    if cv.FUNC.UNPACK then
        gen_unpack_func(cv, write)
    end
    if cv.FUNC.IS then
        gen_is_func(cv, write)
    end
    if cv.FUNC.ISPACK then
        gen_ispack_func(cv, write)
    end
end

local function gen_conv_source(module)
    local arr = {}
    local function append(value)
        arr[#arr + 1] = value
    end

    local HEADER = string.upper(module.NAME)
    local INCLUDES = module.INCLUDES
    append(format([[
        //
        // generated by olua
        //
        ${INCLUDES}
    ]]))
    append('')

    for _, cv in ipairs(module.CONVS) do
        gen_funcs(cv, append)
    end

    olua.write(module.SOURCE_PATH, table.concat(arr, "\n"))
end

function olua.genconv(module, write)
    if write then
        for _, cv in ipairs(module.CONVS) do
            gen_funcs(cv, write)
        end
    else
        gen_conv_header(module)
        gen_conv_source(module)
    end
end