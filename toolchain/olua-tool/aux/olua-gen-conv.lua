local function gen_conv_header(module)
    local HEADER = string.upper(module.NAME)
    local DECL_FUNCS = {}

    for _, cv in ipairs(module.CONVS) do
        DECL_FUNCS[#DECL_FUNCS + 1] = "// " .. cv.CPPCLS
        local CPPCLS = cv.CPPCLS
        local CPPCLS_PATH = class_path(CPPCLS)
        if cv.FUNC.PUSH then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                int auto_luacv_push_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.CHECK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                void auto_luacv_check_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.OPT then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                void auto_luacv_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value, const ${CPPCLS} &def);
            ]])
        end
        if cv.FUNC.PACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                void auto_luacv_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.UNPACK then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                int auto_luacv_unpack_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value);
            ]])
        end
        if cv.FUNC.IS then
            DECL_FUNCS[#DECL_FUNCS + 1] = format_snippet([[
                bool auto_luacv_is_${CPPCLS_PATH}(lua_State *L, int idx);
            ]])
        end
        DECL_FUNCS[#DECL_FUNCS + 1] = ""
    end

    for line in string.gmatch(module.DECLCHUNK or "", '[^\n\r]+') do
        if string.find(line, '%)$') then
            DECL_FUNCS[#DECL_FUNCS + 1] = line .. ';'
        end
    end

    DECL_FUNCS = table.concat(DECL_FUNCS, "\n")
    write(PROJECT_ROOT .. module.HEADER_PATH, format_snippet([[
        //
        // generated by olua
        //
        #ifndef __AUTO_GEN_LUA_${HEADER}_H__
        #define __AUTO_GEN_LUA_${HEADER}_H__

        #include "xgame/xlua.h"
        #include "lua.hpp"

        #include "cocos2d.h"

        ${DECL_FUNCS}

        #endif
    ]]))
end

local function gen_push_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local PUSH_FUNC
        local isbase = true
        local DECL_TYPE = ""
        if pi.TYPE.DECL_TYPE == 'lua_Number' then
            PUSH_FUNC = 'olua_rawsetfieldnumber'
        elseif pi.TYPE.DECL_TYPE == 'lua_Integer'
            or pi.TYPE.DECL_TYPE == 'lua_Unsigned' then
            PUSH_FUNC = 'olua_rawsetfieldinteger'
            DECL_TYPE = '(' .. pi.TYPE.DECL_TYPE .. ')'
        elseif pi.TYPE.TYPENAME == 'std::string' then
            PUSH_FUNC = 'olua_rawsetfieldstring'
            VARNAME = VARNAME .. '.c_str()'
        elseif pi.TYPE.TYPENAME == 'bool' then
            PUSH_FUNC = 'olua_rawsetfieldboolean'
        elseif pi.TYPE.TYPENAME == 'const char *' then
            PUSH_FUNC = 'olua_rawsetfieldstring'
        else
            isbase = false
            PUSH_FUNC = pi.TYPE.FUNC_PUSH_VALUE
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.TYPENAME))
        end
        if isbase then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                ${PUSH_FUNC}(L, -1, "${LUANAME}", ${DECL_TYPE}value->${VARNAME});
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                ${PUSH_FUNC}(L, &value->${VARNAME});
                olua_rawgetfield(L, -2, "${LUANAME}");
            ]])
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format_snippet([[
        int auto_luacv_push_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value)
        {
            if (value) {
                lua_createtable(L, 0, ${NUM_ARGS});
                ${ARGS_CHUNK}
            } else {
                lua_pushnil(L);
            }
            
            return 1;
        }
    ]]))
    write('')
end

local function gen_check_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local TYPENAME = pi.TYPE.TYPENAME
        local CHECK_FUNC
        local isbase = true
        if pi.TYPE.DECL_TYPE == 'lua_Number' then
            CHECK_FUNC = 'olua_checkfieldnumber'
        elseif pi.TYPE.DECL_TYPE == 'lua_Integer'
            or pi.TYPE.DECL_TYPE == 'lua_Unsigned' then
            CHECK_FUNC = 'olua_checkfieldinteger'
        elseif pi.TYPE.TYPENAME == 'std::string' then
            CHECK_FUNC = 'olua_checkfieldstring'
        elseif pi.TYPE.TYPENAME == 'bool' then
            CHECK_FUNC = 'olua_checkfieldboolean'
        elseif pi.TYPE.TYPENAME == 'const char *' then
            CHECK_FUNC = 'olua_checkfieldstring'
        else
            CHECK_FUNC = pi.TYPE.FUNC_CHECK_VALUE
            isbase = false
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.TYPENAME))
        end
        if isbase then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                value->${VARNAME} = (${TYPENAME})${CHECK_FUNC}(L, idx, "${LUANAME}");
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                olua_rawgetfield(L, -1, "${LUANAME}");
                ${CHECK_FUNC}(L, idx, &value->${VARNAME});
                lua_pop(L, 1);
            ]])
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format_snippet([[
        void auto_luacv_check_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            luaL_checktype(L, idx, LUA_TTABLE);
            ${ARGS_CHUNK}
        }
    ]]))
    write('')
end

local function gen_opt_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for _, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local TYPENAME = pi.TYPE.TYPENAME
        local CHECK_FUNC
        local isbase = true
        if pi.TYPE.DECL_TYPE == 'lua_Number' then
            CHECK_FUNC = 'olua_checkfieldnumber'
        elseif pi.TYPE.DECL_TYPE == 'lua_Integer'
            or pi.TYPE.DECL_TYPE == 'lua_Unsigned' then
            CHECK_FUNC = 'olua_checkfieldinteger'
        elseif pi.TYPE.TYPENAME == 'std::string' then
            CHECK_FUNC = 'olua_checkfieldstring'
        elseif pi.TYPE.TYPENAME == 'bool' then
            CHECK_FUNC = 'olua_checkfieldboolean'
        elseif pi.TYPE.TYPENAME == 'const char *' then
            CHECK_FUNC = 'olua_checkfieldstring'
        else
            CHECK_FUNC = pi.TYPE.FUNC_CHECK_VALUE
            isbase = false
            -- error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.TYPENAME))
        end
        if isbase then
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                value->${VARNAME} = (${TYPENAME})${CHECK_FUNC}(L, idx, "${LUANAME}");
            ]])
        else
            ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
                olua_rawgetfield(L, -1, "${LUANAME}");
                ${CHECK_FUNC}(L, idx, &value->${VARNAME});
                lua_pop(L, 1);
            ]])
        end
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format_snippet([[
        void auto_luacv_opt_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value, const ${CPPCLS} &def)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            if (olua_isnil(L, idx)) {
                *value = def;
            } else {
                idx = lua_absindex(L, idx);
                luaL_checktype(L, idx, LUA_TTABLE);
                ${ARGS_CHUNK}
            }
        }
    ]]))
    write('')
end

local function gen_pack_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for i, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local TYPENAME = pi.TYPE.TYPENAME
        local ARG_N = i - 1
        local CHECK_FUNC
        if pi.TYPE.DECL_TYPE == 'lua_Number' then
            CHECK_FUNC = 'olua_checknumber'
        elseif pi.TYPE.DECL_TYPE == 'lua_Integer'
            or pi.TYPE.DECL_TYPE == 'lua_Unsigned' then
            CHECK_FUNC = 'olua_checkinteger'
        elseif pi.TYPE.TYPENAME == 'std::string' then
            CHECK_FUNC = 'olua_checkstring'
        elseif pi.TYPE.TYPENAME == 'bool' then
            CHECK_FUNC = 'olua_checktoboolean'
        elseif pi.TYPE.TYPENAME == 'const char *' then
            CHECK_FUNC = 'olua_checkstring'
        else
            error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.TYPENAME))
        end
        ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
            value->${VARNAME} = (${TYPENAME})${CHECK_FUNC}(L, idx + ${ARG_N});
        ]])
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format_snippet([[
        void auto_luacv_pack_${CPPCLS_PATH}(lua_State *L, int idx, ${CPPCLS} *value)
        {
            if (!value) {
                luaL_error(L, "value is NULL");
            }
            idx = lua_absindex(L, idx);
            ${ARGS_CHUNK}
        }
    ]]))
    write('')
end

local function gen_unpack_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    local NUM_ARGS = #cv.PROPS
    local ARGS_CHUNK = {}

    for i, pi in ipairs(cv.PROPS) do
        local LUANAME = pi.LUANAME
        local VARNAME = pi.VARNAME
        local TYPENAME = pi.TYPE.TYPENAME
        local ARG_N = i - 1
        local PUSH_FUNC
        if pi.TYPE.DECL_TYPE == 'lua_Number' then
            PUSH_FUNC = 'lua_pushnumber'
        elseif pi.TYPE.DECL_TYPE == 'lua_Integer'
            or pi.TYPE.DECL_TYPE == 'lua_Unsigned' then
            PUSH_FUNC = 'lua_pushinteger'
        elseif pi.TYPE.TYPENAME == 'std::string' then
            PUSH_FUNC = 'lua_pushstring'
            VARNAME = VARNAME .. '.c_str()'
        elseif pi.TYPE.TYPENAME == 'bool' then
            PUSH_FUNC = 'lua_pushboolean'
        elseif pi.TYPE.TYPENAME == 'const char *' then
            PUSH_FUNC = 'lua_pushstring'
        else
            error(string.format("%s %s %s", cv.VARNAME, cv.LUANAME, cv.TYPE.TYPENAME))
        end
        ARGS_CHUNK[#ARGS_CHUNK + 1] = format_snippet([[
            ${PUSH_FUNC}(L, value->${VARNAME});
        ]])
    end

    ARGS_CHUNK = table.concat(ARGS_CHUNK, "\n")
    write(format_snippet([[
        int auto_luacv_unpack_${CPPCLS_PATH}(lua_State *L, const ${CPPCLS} *value)
        {
            if (value) {
                ${ARGS_CHUNK}
            } else {
                for (int i = 0; i < ${NUM_ARGS}; i++) {
                    lua_pushnil(L);
                }
            }
            
            return ${NUM_ARGS};
        }
    ]]))
    write('')
end

local function gen_is_func(cv, write)
    local CPPCLS = cv.CPPCLS
    local CPPCLS_PATH = class_path(CPPCLS)
    write(format_snippet([[
        bool auto_luacv_is_${CPPCLS_PATH}(lua_State *L, int idx)
        {
            return lua_istable(L, idx);
        }
    ]]))
    write('')
end

local function gen_funcs(cv, write)
    if cv.FUNC.PUSH then
        gen_push_func(cv, write)
    end
    if cv.FUNC.CHECK then
        gen_check_func(cv, write)
    end
    if cv.FUNC.OPT then
        gen_opt_func(cv, write)
    end
    if cv.FUNC.PACK then
        gen_pack_func(cv, write)
    end
    if cv.FUNC.UNPACK then
        gen_unpack_func(cv, write)
    end
    if cv.FUNC.IS then
        gen_is_func(cv, write)
    end
end

local function gen_conv_source(module)
    local arr = {}
    local function append(value)
        arr[#arr + 1] = value
    end

    local HEADER = string.upper(module.NAME)
    local INCLUDES = module.INCLUDES
    append(format_snippet([[
        //
        // generated by olua
        //
        ${INCLUDES}
    ]]))

    for _, cv in ipairs(module.CONVS) do
        gen_funcs(cv, append)
    end

    append(module.DECLCHUNK)

    write(PROJECT_ROOT .. module.SOURCE_PATH, table.concat(arr, "\n"))
end

function gen_conv(module)
    gen_conv_header(module)
    gen_conv_source(module)
end