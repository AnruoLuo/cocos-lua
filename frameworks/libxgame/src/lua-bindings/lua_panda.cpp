#include "lua_panda.h"

static const char* DebugTools = 
"--工具函数\n"
"local DebugTools = {};\n"
"local this = DebugTools;\n"
"\n"
"function this.getFileSource()\n"
"    local info = debug.getinfo(1, \"S\")\n"
"    for k,v in pairs(info) do\n"
"        if k == \"source\" then\n"
"            return v;\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"--序列化并打印table\n"
"function this.printTable(t, name ,indent)\n"
"    local str = (this.show(t, name, indent));\n"
"    print(str);\n"
"end\n"
"\n"
"--序列化并返回table\n"
"function this.serializeTable(t, name, indent)\n"
"  local str = (this.show(t, name, indent))\n"
"  return str\n"
"end\n"
"\n"
"--[[\n"
"Author: Julio Manuel Fernandez-Diaz\n"
"Date:   January 12, 2007\n"
"Modified slightly by RiciLake to avoid the unnecessary table traversal in tablecount()\n"
"Formats tables with cycles recursively to any depth.\n"
"The output is returned as a string.\n"
"References to other tables are shown as values.\n"
"Self references are indicated.\n"
"The string returned is \"Lua code\", which can be procesed\n"
"(in the case in which indent is composed by spaces or \"--\").\n"
"Userdata and function keys and values are shown as strings,\n"
"which logically are exactly not equivalent to the original code.\n"
"This routine can serve for pretty formating tables with\n"
"proper indentations, apart from printing them:\n"
"print(table.show(t, \"t\"))   -- a typical use\n"
"Heavily based on \"Saving tables with cycles\", PIL2, p. 113.\n"
"Arguments:\n"
"t is the table.\n"
"name is the name of the table (optional)\n"
"indent is a first indentation (optional).\n"
"--]]\n"
"function this.show(t, name, indent)\n"
"    local cart     -- a container\n"
"    local autoref  -- for self references\n"
"\n"
"    local function isemptytable(t) return next(t) == nil end\n"
"\n"
"    local function basicSerialize (o)\n"
"      local so = tostring(o)\n"
"      if type(o) == \"function\" then\n"
"         local info = debug.getinfo(o, \"S\")\n"
"         -- info.name is nil because o is not a calling level\n"
"         if info.what == \"C\" then\n"
"            return string.format(\"%q\", so .. \", C function\")\n"
"         else\n"
"            -- the information is defined through lines\n"
"            return string.format(\"%q\", so .. \", defined in (\" ..\n"
"                info.linedefined .. \"-\" .. info.lastlinedefined ..\n"
"                \")\" .. info.source)\n"
"         end\n"
"      elseif type(o) == \"number\" or type(o) == \"boolean\" then\n"
"         return so\n"
"      else\n"
"         return string.format(\"%q\", so)\n"
"      end\n"
"    end\n"
"\n"
"    local function addtocart (value, name, indent, saved, field)\n"
"      indent = indent or \"\"\n"
"      saved = saved or {}\n"
"      field = field or name\n"
"\n"
"      cart = cart .. indent .. field\n"
"\n"
"      if type(value) ~= \"table\" then\n"
"         cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"\n"
"      else\n"
"         if saved[value] then\n"
"            cart = cart .. \" = {}; -- \" .. saved[value]\n"
"                        .. \" (self reference)\\n\"\n"
"            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\n"
"         else\n"
"            saved[value] = name\n"
"            --if tablecount(value) == 0 then\n"
"            if isemptytable(value) then\n"
"               cart = cart .. \" = {};\\n\"\n"
"            else\n"
"               cart = cart .. \" = {\\n\"\n"
"               for k, v in pairs(value) do\n"
"                  k = basicSerialize(k)\n"
"                  local fname = string.format(\"%s[%s]\", name, k)\n"
"                  field = string.format(\"[%s]\", k)\n"
"                  -- three spaces between levels\n"
"                  addtocart(v, fname, indent .. \"   \", saved, field)\n"
"               end\n"
"               cart = cart .. indent .. \"};\\n\"\n"
"            end\n"
"         end\n"
"      end\n"
"    end\n"
"\n"
"    name = name or \"PRINT_Table\"\n"
"    if type(t) ~= \"table\" then\n"
"      return name .. \" = \" .. basicSerialize(t)\n"
"    end\n"
"    cart, autoref = \"\", \"\"\n"
"    addtocart(t, name, indent)\n"
"    return cart .. autoref\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- JSON4Lua: JSON encoding / decoding support for the Lua language.\n"
"-- json Module.\n"
"-- Author: Craig Mason-Jones\n"
"-- Homepage: http://github.com/craigmj/json4lua/\n"
"-- Version: 1.0.0\n"
"-- This module is released under the MIT License (MIT).\n"
"-- Please see LICENCE.txt for details.\n"
"--\n"
"-- USAGE:\n"
"-- This module exposes two functions:\n"
"--   json.encode(o)\n"
"--     Returns the table / string / boolean / number / nil / json.null value as a JSON-encoded string.\n"
"--   json.decode(json_string)\n"
"--     Returns a Lua object populated with the data encoded in the JSON string json_string.\n"
"--\n"
"-- REQUIREMENTS:\n"
"--   compat-5.1 if using Lua 5.0\n"
"--\n"
"-- CHANGELOG\n"
"--   0.9.20 Introduction of local Lua functions for private functions (removed _ function prefix).\n"
"--          Fixed Lua 5.1 compatibility issues.\n"
"--   \t\tIntroduced json.null to have null values in associative arrays.\n"
"--          json.encode() performance improvement (more than 50%) through table.concat rather than ..\n"
"--          Introduced decode ability to ignore /**/ comments in the JSON string.\n"
"--   0.9.10 Fix to array encoding / decoding to correctly manage nil/null values in arrays.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function this.createJson()\n"
"    -----------------------------------------------------------------------------\n"
"    -- Imports and dependencies\n"
"    -----------------------------------------------------------------------------\n"
"    local math = require('math')\n"
"    local string = require(\"string\")\n"
"    local table = require(\"table\")\n"
"\n"
"    -----------------------------------------------------------------------------\n"
"    -- Module declaration\n"
"    -----------------------------------------------------------------------------\n"
"    local json = {}             -- Public namespace\n"
"    local json_private = {}     -- Private namespace\n"
"\n"
"    -- Public constants\n"
"    json.EMPTY_ARRAY={}\n"
"    json.EMPTY_OBJECT={}\n"
"\n"
"    -- Public functions\n"
"\n"
"    -- Private functions\n"
"    local decode_scanArray\n"
"    local decode_scanComment\n"
"    local decode_scanConstant\n"
"    local decode_scanNumber\n"
"    local decode_scanObject\n"
"    local decode_scanString\n"
"    local decode_scanWhitespace\n"
"    local encodeString\n"
"    local isArray\n"
"    local isEncodable\n"
"\n"
"    -----------------------------------------------------------------------------\n"
"    -- PUBLIC FUNCTIONS\n"
"    -----------------------------------------------------------------------------\n"
"    --- Encodes an arbitrary Lua object / variable.\n"
"    -- @param v The Lua object / variable to be JSON encoded.\n"
"    -- @return String containing the JSON encoding in internal Lua string format (i.e. not unicode)\n"
"    function json.encode (v)\n"
"        -- Handle nil values\n"
"        if v==nil then\n"
"            return \"null\"\n"
"        end\n"
"\n"
"        local vtype = type(v)\n"
"\n"
"        -- Handle strings\n"
"        if vtype=='string' then\n"
"            return '\"' .. json_private.encodeString(v) .. '\"'\t    -- Need to handle encoding in string\n"
"        end\n"
"\n"
"        -- Handle booleans\n"
"        if vtype=='number' or vtype=='boolean' then\n"
"            return tostring(v)\n"
"        end\n"
"\n"
"        -- Handle tables\n"
"        if vtype=='table' then\n"
"            local rval = {}\n"
"            -- Consider arrays separately\n"
"            local bArray, maxCount = isArray(v)\n"
"            if bArray then\n"
"                for i = 1,maxCount do\n"
"                    table.insert(rval, json.encode(v[i]))\n"
"                end\n"
"            else\t-- An object, not an array\n"
"                for i,j in pairs(v) do\n"
"                    if isEncodable(i) and isEncodable(j) then\n"
"                        table.insert(rval, '\"' .. json_private.encodeString(i) .. '\":' .. json.encode(j))\n"
"                    end\n"
"                end\n"
"            end\n"
"            if bArray then\n"
"                return '[' .. table.concat(rval,',') ..']'\n"
"            else\n"
"                return '{' .. table.concat(rval,',') .. '}'\n"
"            end\n"
"        end\n"
"\n"
"        -- Handle null values\n"
"        if vtype=='function' and v==json.null then\n"
"            return 'null'\n"
"        end\n"
"\n"
"        assert(false,'encode attempt to encode unsupported type ' .. vtype .. ':' .. tostring(v))\n"
"    end\n"
"\n"
"\n"
"    --- Decodes a JSON string and returns the decoded value as a Lua data structure / value.\n"
"    -- @param s The string to scan.\n"
"    -- @param [startPos] Optional starting position where the JSON string is located. Defaults to 1.\n"
"    -- @param Lua object, number The object that was scanned, as a Lua table / string / number / boolean or nil,\n"
"    -- and the position of the first character after\n"
"    -- the scanned JSON object.\n"
"    function json.decode(s, startPos)\n"
"        startPos = startPos and startPos or 1\n"
"        startPos = decode_scanWhitespace(s,startPos)\n"
"        assert(startPos<=string.len(s), 'Unterminated JSON encoded object found at position in [' .. s .. ']')\n"
"        local curChar = string.sub(s,startPos,startPos)\n"
"        -- Object\n"
"        if curChar=='{' then\n"
"            return decode_scanObject(s,startPos)\n"
"        end\n"
"        -- Array\n"
"        if curChar=='[' then\n"
"            return decode_scanArray(s,startPos)\n"
"        end\n"
"        -- Number\n"
"        if string.find(\"+-0123456789.e\", curChar, 1, true) then\n"
"            return decode_scanNumber(s,startPos)\n"
"        end\n"
"        -- String\n"
"        if curChar==[[\"]] or curChar==[[']] then\n"
"            return decode_scanString(s,startPos)\n"
"        end\n"
"        if string.sub(s,startPos,startPos+1)=='/*' then\n"
"            return json.decode(s, decode_scanComment(s,startPos))\n"
"        end\n"
"        -- Otherwise, it must be a constant\n"
"        return decode_scanConstant(s,startPos)\n"
"    end\n"
"\n"
"    --- The null function allows one to specify a null value in an associative array (which is otherwise\n"
"    -- discarded if you set the value with 'nil' in Lua. Simply set t = { first=json.null }\n"
"    function json.null()\n"
"        return json.null -- so json.null() will also return null ;-)\n"
"    end\n"
"    -----------------------------------------------------------------------------\n"
"    -- Internal, PRIVATE functions.\n"
"    -- Following a Python-like convention, I have prefixed all these 'PRIVATE'\n"
"    -- functions with an underscore.\n"
"    -----------------------------------------------------------------------------\n"
"\n"
"    --- Scans an array from JSON into a Lua object\n"
"    -- startPos begins at the start of the array.\n"
"    -- Returns the array and the next starting position\n"
"    -- @param s The string being scanned.\n"
"    -- @param startPos The starting position for the scan.\n"
"    -- @return table, int The scanned array as a table, and the position of the next character to scan.\n"
"    function decode_scanArray(s,startPos)\n"
"        local array = {}\t-- The return value\n"
"        local stringLen = string.len(s)\n"
"        assert(string.sub(s,startPos,startPos)=='[','decode_scanArray called but array does not start at position ' .. startPos .. ' in string:\\n'..s )\n"
"        startPos = startPos + 1\n"
"        -- Infinite loop for array elements\n"
"        local index = 1\n"
"        repeat\n"
"            startPos = decode_scanWhitespace(s,startPos)\n"
"            assert(startPos<=stringLen,'JSON String ended unexpectedly scanning array.')\n"
"            local curChar = string.sub(s,startPos,startPos)\n"
"            if (curChar==']') then\n"
"                return array, startPos+1\n"
"            end\n"
"            if (curChar==',') then\n"
"                startPos = decode_scanWhitespace(s,startPos+1)\n"
"            end\n"
"            assert(startPos<=stringLen, 'JSON String ended unexpectedly scanning array.')\n"
"            object, startPos = json.decode(s,startPos)\n"
"            array[index] = object\n"
"            index = index + 1\n"
"        until false\n"
"    end\n"
"\n"
"    --- Scans a comment and discards the comment.\n"
"    -- Returns the position of the next character following the comment.\n"
"    -- @param string s The JSON string to scan.\n"
"    -- @param int startPos The starting position of the comment\n"
"    function decode_scanComment(s, startPos)\n"
"        assert( string.sub(s,startPos,startPos+1)=='/*', \"decode_scanComment called but comment does not start at position \" .. startPos)\n"
"        local endPos = string.find(s,'*/',startPos+2)\n"
"        assert(endPos~=nil, \"Unterminated comment in string at \" .. startPos)\n"
"        return endPos+2\n"
"    end\n"
"\n"
"    --- Scans for given constants: true, false or null\n"
"    -- Returns the appropriate Lua type, and the position of the next character to read.\n"
"    -- @param s The string being scanned.\n"
"    -- @param startPos The position in the string at which to start scanning.\n"
"    -- @return object, int The object (true, false or nil) and the position at which the next character should be\n"
"    -- scanned.\n"
"    function decode_scanConstant(s, startPos)\n"
"        local consts = { [\"true\"] = true, [\"false\"] = false, [\"null\"] = nil }\n"
"        local constNames = {\"true\",\"false\",\"null\"}\n"
"\n"
"        for i,k in pairs(constNames) do\n"
"            if string.sub(s,startPos, startPos + string.len(k) -1 )==k then\n"
"                return consts[k], startPos + string.len(k)\n"
"            end\n"
"        end\n"
"        assert(nil, 'Failed to scan constant from string ' .. s .. ' at starting position ' .. startPos)\n"
"    end\n"
"\n"
"    --- Scans a number from the JSON encoded string.\n"
"    -- (in fact, also is able to scan numeric +- eqns, which is not\n"
"    -- in the JSON spec.)\n"
"    -- Returns the number, and the position of the next character\n"
"    -- after the number.\n"
"    -- @param s The string being scanned.\n"
"    -- @param startPos The position at which to start scanning.\n"
"    -- @return number, int The extracted number and the position of the next character to scan.\n"
"    function decode_scanNumber(s,startPos)\n"
"        local endPos = startPos+1\n"
"        local stringLen = string.len(s)\n"
"        local acceptableChars = \"+-0123456789.e\"\n"
"        while (string.find(acceptableChars, string.sub(s,endPos,endPos), 1, true)\n"
"        and endPos<=stringLen\n"
"        ) do\n"
"            endPos = endPos + 1\n"
"        end\n"
"        -- local stringValue = 'return ' .. string.sub(s, startPos, endPos - 1)\n"
"        -- local stringEval = loadstring(stringValue)\n"
"        -- assert(stringEval, 'Failed to scan number [ ' .. stringValue .. '] in JSON string at position ' .. startPos .. ' : ' .. endPos)\n"
"        local numberValue = string.sub(s, startPos, endPos - 1)\n"
"        return numberValue, endPos\n"
"    end\n"
"\n"
"    --- Scans a JSON object into a Lua object.\n"
"    -- startPos begins at the start of the object.\n"
"    -- Returns the object and the next starting position.\n"
"    -- @param s The string being scanned.\n"
"    -- @param startPos The starting position of the scan.\n"
"    -- @return table, int The scanned object as a table and the position of the next character to scan.\n"
"    function decode_scanObject(s,startPos)\n"
"        local object = {}\n"
"        local stringLen = string.len(s)\n"
"        local key, value\n"
"        assert(string.sub(s,startPos,startPos)=='{','decode_scanObject called but object does not start at position ' .. startPos .. ' in string:\\n' .. s)\n"
"        startPos = startPos + 1\n"
"        repeat\n"
"            startPos = decode_scanWhitespace(s,startPos)\n"
"            assert(startPos<=stringLen, 'JSON string ended unexpectedly while scanning object.')\n"
"            local curChar = string.sub(s,startPos,startPos)\n"
"            if (curChar=='}') then\n"
"                return object,startPos+1\n"
"            end\n"
"            if (curChar==',') then\n"
"                startPos = decode_scanWhitespace(s,startPos+1)\n"
"            end\n"
"            assert(startPos<=stringLen, 'JSON string ended unexpectedly scanning object.')\n"
"            -- Scan the key\n"
"            key, startPos = json.decode(s,startPos)\n"
"            assert(startPos<=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)\n"
"            startPos = decode_scanWhitespace(s,startPos)\n"
"            assert(startPos<=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)\n"
"            assert(string.sub(s,startPos,startPos)==':','JSON object key-value assignment mal-formed at ' .. startPos)\n"
"            startPos = decode_scanWhitespace(s,startPos+1)\n"
"            assert(startPos<=stringLen, 'JSON string ended unexpectedly searching for value of key ' .. key)\n"
"            value, startPos = json.decode(s,startPos)\n"
"            object[key]=value\n"
"        until false\t-- infinite loop while key-value pairs are found\n"
"    end\n"
"\n"
"    -- START SoniEx2\n"
"    -- Initialize some things used by decode_scanString\n"
"    -- You know, for efficiency\n"
"    local escapeSequences = {\n"
"        [\"\\\\t\"] = \"\\t\",\n"
"        [\"\\\\f\"] = \"\\f\",\n"
"        [\"\\\\r\"] = \"\\r\",\n"
"        [\"\\\\n\"] = \"\\n\",\n"
"        [\"\\\\b\"] = \"\\b\"\n"
"    }\n"
"    setmetatable(escapeSequences, {__index = function(t,k)\n"
"        -- skip \"\\\" aka strip escape\n"
"        return string.sub(k,2)\n"
"    end})\n"
"    -- END SoniEx2\n"
"\n"
"    --- Scans a JSON string from the opening inverted comma or single quote to the\n"
"    -- end of the string.\n"
"    -- Returns the string extracted as a Lua string,\n"
"    -- and the position of the next non-string character\n"
"    -- (after the closing inverted comma or single quote).\n"
"    -- @param s The string being scanned.\n"
"    -- @param startPos The starting position of the scan.\n"
"    -- @return string, int The extracted string as a Lua string, and the next character to parse.\n"
"    function decode_scanString(s,startPos)\n"
"        assert(startPos, 'decode_scanString(..) called without start position')\n"
"        local startChar = string.sub(s,startPos,startPos)\n"
"        -- START SoniEx2\n"
"        -- PS: I don't think single quotes are valid JSON\n"
"        assert(startChar == [[\"]] or startChar == [[']],'decode_scanString called for a non-string')\n"
"        --assert(startPos, \"String decoding failed: missing closing \" .. startChar .. \" for string at position \" .. oldStart)\n"
"        local t = {}\n"
"        local i,j = startPos,startPos\n"
"        while string.find(s, startChar, j+1) ~= j+1 do\n"
"            local oldj = j\n"
"            i,j = string.find(s, \"\\\\.\", j+1)\n"
"            local x,y = string.find(s, startChar, oldj+1)\n"
"            if not i or x < i then\n"
"                i,j = x,y-1\n"
"            end\n"
"            table.insert(t, string.sub(s, oldj+1, i-1))\n"
"            if string.sub(s, i, j) == \"\\\\u\" then\n"
"                local a = string.sub(s,j+1,j+4)\n"
"                j = j + 4\n"
"                local n = tonumber(a, 16)\n"
"                assert(n, \"String decoding failed: bad Unicode escape \" .. a .. \" at position \" .. i .. \" : \" .. j)\n"
"                -- math.floor(x/2^y) == lazy right shift\n"
"                -- a % 2^b == bitwise_and(a, (2^b)-1)\n"
"                -- 64 = 2^6\n"
"                -- 4096 = 2^12 (or 2^6 * 2^6)\n"
"                local x\n"
"                if n < 0x80 then\n"
"                    x = string.char(n % 0x80)\n"
"                elseif n < 0x800 then\n"
"                    -- [110x xxxx] [10xx xxxx]\n"
"                    x = string.char(0xC0 + (math.floor(n/64) % 0x20), 0x80 + (n % 0x40))\n"
"                else\n"
"                    -- [1110 xxxx] [10xx xxxx] [10xx xxxx]\n"
"                    x = string.char(0xE0 + (math.floor(n/4096) % 0x10), 0x80 + (math.floor(n/64) % 0x40), 0x80 + (n % 0x40))\n"
"                end\n"
"                table.insert(t, x)\n"
"            else\n"
"                table.insert(t, escapeSequences[string.sub(s, i, j)])\n"
"            end\n"
"        end\n"
"        table.insert(t,string.sub(j, j+1))\n"
"        assert(string.find(s, startChar, j+1), \"String decoding failed: missing closing \" .. startChar .. \" at position \" .. j .. \"(for string at position \" .. startPos .. \")\")\n"
"        return table.concat(t,\"\"), j+2\n"
"        -- END SoniEx2\n"
"    end\n"
"\n"
"    --- Scans a JSON string skipping all whitespace from the current start position.\n"
"    -- Returns the position of the first non-whitespace character, or nil if the whole end of string is reached.\n"
"    -- @param s The string being scanned\n"
"    -- @param startPos The starting position where we should begin removing whitespace.\n"
"    -- @return int The first position where non-whitespace was encountered, or string.len(s)+1 if the end of string\n"
"    -- was reached.\n"
"    function decode_scanWhitespace(s,startPos)\n"
"        local whitespace=\" \\n\\r\\t\"\n"
"        local stringLen = string.len(s)\n"
"        while ( string.find(whitespace, string.sub(s,startPos,startPos), 1, true)  and startPos <= stringLen) do\n"
"            startPos = startPos + 1\n"
"        end\n"
"        return startPos\n"
"    end\n"
"\n"
"    --- Encodes a string to be JSON-compatible.\n"
"    -- This just involves back-quoting inverted commas, back-quotes and newlines, I think ;-)\n"
"    -- @param s The string to return as a JSON encoded (i.e. backquoted string)\n"
"    -- @return The string appropriately escaped.\n"
"\n"
"    local escapeList = {\n"
"            ['\"']  = '\\\\\"',\n"
"            ['\\\\'] = '\\\\\\\\',\n"
"            ['/']  = '\\\\/',\n"
"            ['\\b'] = '\\\\b',\n"
"            ['\\f'] = '\\\\f',\n"
"            ['\\n'] = '\\\\n',\n"
"            ['\\r'] = '\\\\r',\n"
"            ['\\t'] = '\\\\t'\n"
"    }\n"
"\n"
"    function json_private.encodeString(s)\n"
"    local s = tostring(s)\n"
"    return s:gsub(\".\", function(c) return escapeList[c] end) -- SoniEx2: 5.0 compat\n"
"    end\n"
"\n"
"    -- Determines whether the given Lua type is an array or a table / dictionary.\n"
"    -- We consider any table an array if it has indexes 1..n for its n items, and no\n"
"    -- other data in the table.\n"
"    -- I think this method is currently a little 'flaky', but can't think of a good way around it yet...\n"
"    -- @param t The table to evaluate as an array\n"
"    -- @return boolean, number True if the table can be represented as an array, false otherwise. If true,\n"
"    -- the second returned value is the maximum\n"
"    -- number of indexed elements in the array.\n"
"    function isArray(t)\n"
"        -- Next we count all the elements, ensuring that any non-indexed elements are not-encodable\n"
"        -- (with the possible exception of 'n')\n"
"        if (t == json.EMPTY_ARRAY) then return true, 0 end\n"
"        if (t == json.EMPTY_OBJECT) then return false end\n"
"\n"
"        local maxIndex = 0\n"
"        for k,v in pairs(t) do\n"
"            if (type(k)=='number' and math.floor(k)==k and 1<=k) then\t-- k,v is an indexed pair\n"
"                if (not isEncodable(v)) then return false end\t-- All array elements must be encodable\n"
"                maxIndex = math.max(maxIndex,k)\n"
"            else\n"
"                if (k=='n') then\n"
"                    if v ~= (t.n or #t) then return false end  -- False if n does not hold the number of elements\n"
"                else -- Else of (k=='n')\n"
"                    if isEncodable(v) then return false end\n"
"                end  -- End of (k~='n')\n"
"            end -- End of k,v not an indexed pair\n"
"        end  -- End of loop across all pairs\n"
"        return true, maxIndex\n"
"    end\n"
"\n"
"    --- Determines whether the given Lua object / table / variable can be JSON encoded. The only\n"
"    -- types that are JSON encodable are: string, boolean, number, nil, table and json.null.\n"
"    -- In this implementation, all other types are ignored.\n"
"    -- @param o The object to examine.\n"
"    -- @return boolean True if the object should be JSON encoded, false if it should be ignored.\n"
"    function isEncodable(o)\n"
"        local t = type(o)\n"
"        return (t=='string' or t=='boolean' or t=='number' or t=='nil' or t=='table') or\n"
"            (t=='function' and o==json.null)\n"
"    end\n"
"    return json\n"
"end\n"
"\n"
"-- Sourced from http://lua-users.org/wiki/BaseSixtyFour\n"
"\n"
"-- Lua 5.1+ base64 v3.0 (c) 2009 by Alex Kloss <alexthkloss@web.de>\n"
"-- licensed under the terms of the LGPL2\n"
"\n"
"-- character table string\n"
"local base64CharTable='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n"
"\n"
"-- encoding\n"
"function this.base64encode(data)\n"
"    return ((data:gsub('.', function(x)\n"
"        local r,b='',x:byte()\n"
"        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n"
"        if (#x < 6) then return '' end\n"
"        local c=0\n"
"        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n"
"        return base64CharTable:sub(c+1,c+1)\n"
"    end)..({ '', '==', '=' })[#data%3+1])\n"
"end\n"
"\n"
"-- decoding\n"
"function this.base64decode(data)\n"
"    data = string.gsub(data, '[^'..base64CharTable..'=]', '')\n"
"    return (data:gsub('.', function(x)\n"
"        if (x == '=') then return '' end\n"
"        local r,f='',(base64CharTable:find(x)-1)\n"
"        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\n"
"        if (#x ~= 8) then return '' end\n"
"        local c=0\n"
"        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\n"
"        return string.char(c)\n"
"    end))\n"
"end\n"
"return this;\n";

static const char* LuaPanda =
"--[[\n"
"Tencent is pleased to support the open source community by making LuaPanda available.\n"
"Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.\n"
"Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n"
"https://opensource.org/licenses/BSD-3-Clause\n"
"Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n"
"\n"
"API:\n"
"    LuaPanda.printToVSCode(logStr, printLevel, type)\n"
"        打印日志到VSCode Output下Debugger/log中\n"
"        @printLevel: debug(0)/info(1)/error(2) 这里的日志等级需高于launch.json中配置等级日志才能输出 (可选参数，默认0)\n"
"        @type: 0:VSCode output console  1:VSCode tip (可选参数，默认0)\n"
"\n"
"    LuaPanda.BP()\n"
"        强制打断点，可以在协程中使用。建议使用以下写法:\n"
"        local ret = LuaPanda and LuaPanda.BP and LuaPanda.BP();\n"
"        如果成功加入断点ret返回true，否则是nil\n"
"\n"
"    LuaPanda.getInfo()\n"
"        返回获取调试器信息。包括版本号，是否使用lib库，系统是否支持loadstring(load方法)\n"
"\n"
"    LuaPanda.doctor()\n"
"        返回对当前环境的诊断信息，提示可能存在的问题。\n"
"\n"
"    LuaPanda.getCWD()\n"
"        用户可以调用或在调试控制台中输出这个函数，返回帮助设置CWD的路径。比如\n"
"        cwd:      F:/1/2/3/4/5\n"
"        getinfo:  @../../../../../unreal_10/slua-unreal_1018/Content//Lua/TestArray.lua\n"
"        format:   f:/unreal_10/slua-unreal_1018/Content/Lua/TestArray.lua\n"
"        cwd是vscode传来的配置路径。getinfo是通过getinfo获取到的正在运行的文件路径。format是经过 cwd + getinfo 整合后的格式化路径。\n"
"        format是传给VSCode的最终路径。\n"
"        如果format路径和文件真实路径不符，导致VSCode找不到文件，通过调整工程中launch.json的cwd，使format路径和真实路径一致。\n"
"\n"
"    LuaPanda.getBreaks()\n"
"        获取断点信息\n"
"\n"
"    LuaPanda.printTable(table)\n"
"        序列化打印table\n"
"]]\n"
"\n"
"--用户设置项\n"
"local openAttachMode = true;            --是否开启attach模式。attach模式开启后可以在任意时刻启动vscode连接调试。缺点是没有连接调试时也会略降低lua执行效率(会不断进行attach请求)\n"
"local attachInterval = 1;               --attach间隔时间(s)\n"
"local customGetSocketInstance = nil;    --支持用户实现一个自定义调用luasocket的函数，函数返回值必须是一个socket实例。例: function() return require(\"socket.core\").tcp() end;\n"
"local consoleLogLevel = 2;           --打印在控制台(print)的日志等级 0 : all/ 1: info/ 2: error.\n"
"local connectTimeoutSec = 0.005;       --等待连接超时时间, 单位s. 时间过长等待attach时会造成卡顿，时间过短可能无法连接。建议值0.005 - 0.05\n"
"--用户设置项END\n"
"\n"
"local debuggerVer = \"2.2.1\";                 --debugger版本号\n"
"LuaPanda = {};\n"
"local this = LuaPanda;\n"
"local tools = require(\"DebugTools\");     --引用的开源工具，包括json解析和table展开工具等\n"
"this.tools = tools;\n"
"this.curStackId = 0;\n"
"--json处理\n"
"local json = tools.createJson()\n"
"--hook状态列表\n"
"local hookState = {\n"
"    DISCONNECT_HOOK = 0,                --断开连接\n"
"    LITE_HOOK = 1,              --全局无断点\n"
"    MID_HOOK = 2,               --全局有断点，本文件无断点\n"
"    ALL_HOOK = 3,               --本文件有断点\n"
"};\n"
"--运行状态列表\n"
"local runState = {\n"
"    DISCONNECT = 0,             --未连接\n"
"    WAIT_CMD = 1,               --已连接，等待命令\n"
"    STOP_ON_ENTRY = 2,          --初始状态\n"
"    RUN = 3,\n"
"    STEPOVER = 4,\n"
"    STEPIN = 5,\n"
"    STEPOUT = 6,\n"
"    STEPOVER_STOP = 7,\n"
"    STEPIN_STOP = 8,\n"
"    STEPOUT_STOP = 9,\n"
"    HIT_BREAKPOINT = 10\n"
"};\n"
"\n"
"local TCPSplitChar = \"|*|\";             --json协议分隔符，请不要修改\n"
"local MAX_TIMEOUT_SEC = 3600 * 24;   --网络最大超时等待时间\n"
"--当前运行状态\n"
"local currentRunState;\n"
"local currentHookState;\n"
"--断点信息\n"
"local breaks = {};              --保存断点的数组\n"
"this.breaks = breaks;           --供hookLib调用\n"
"local recCallbackId = \"\";\n"
"--VSCode端传过来的配置，在VSCode端的launch配置，传过来并赋值\n"
"local luaFileExtension = \"\";    --脚本后缀\n"
"local cwd = \"\";                 --工作路径\n"
"local DebuggerFileName = \"\";    --Debugger文件名(原始,未经path处理), 函数中会自动获取\n"
"local DebuggerToolsName = \"\";\n"
"local lastRunFunction = {};     --上一个执行过的函数。在有些复杂场景下(find,getcomponent)一行会挺两次\n"
"local currentCallStack = {};    --获取当前调用堆栈信息\n"
"local debugMode = false;        --是否开启调试模式\n"
"local hitBP = false;            --BP()中的强制断点命中标记\n"
"local TempFilePath_luaString = \"\"; --VSCode端配置的临时文件存放路径\n"
"local connectHost;              --记录连接端IP\n"
"local connectPort;              --记录连接端口号\n"
"local sock;                     --tcp socket\n"
"local OSType;                --VSCode识别出的系统类型，也可以自行设置。Windows_NT | Linux | Darwin\n"
"local clibPath;                 --chook库在VScode端的路径，也可自行设置。\n"
"local hookLib;                  --chook库的引用实例\n"
"local adapterVer;               --VScode传来的adapter版本号\n"
"--标记位\n"
"local logLevel = 1;             --日志等级all/info/error. 此设置对应的是VSCode端设置的日志等级.\n"
"local variableRefIdx = 1;       --变量索引\n"
"local variableRefTab = {};      --变量记录table\n"
"local lastRunFilePath = \"\";     --最后执行的文件路径\n"
"local pathCaseSensitivity = 1;  --路径是否发大小写敏感，这个选项接收VScode设置，请勿在此处更改\n"
"local recvMsgQueue = {};        --接收的消息队列\n"
"local coroutinePool = {};       --保存用户协程的队列\n"
"local winDiskSymbolUpper = false;--设置win下盘符的大小写。以此确保从VSCode中传入的断点路径,cwd和从lua虚拟机获得的文件路径盘符大小写一致\n"
"local isNeedB64EncodeStr = false;-- 记录是否使用base64编码字符串\n"
"local loadclibErrReason = 'launch.json文件的配置项useCHook被设置为false.';\n"
"local OSTypeErrTip = \"\";\n"
"local pathErrTip = \"\"\n"
"local winDiskSymbolTip = \"\";\n"
"local isAbsolutePath = false;\n"
"local stopOnEntry;         --用户在VSCode端设置的是否打开stopOnEntry\n"
"local userSetUseClib;    --用户在VSCode端设置的是否是用clib库\n"
"--Step控制标记位\n"
"local stepOverCounter = 0;      --STEPOVER over计数器\n"
"local stepOutCounter = 0;       --STEPOVER out计数器\n"
"local HOOK_LEVEL = 3;           --调用栈偏移量，使用clib时为3，lua中不再使用此变量，而是通过函数getSpecificFunctionStackLevel获取\n"
"local isUseLoadstring = 0;\n"
"local debugger_loadString;\n"
"--临时变量\n"
"local coroutineCreate;          --用来记录lua原始的coroutine.create函数\n"
"local stopConnectTime = 0;      --用来临时记录stop断开连接的时间\n"
"local isInMainThread;\n"
"local receiveMsgTimer = 0;\n"
"local pathFormatCache = {};\n"
"local isUserSetClibPath = false;        --用户是否在本文件中自设了clib路径\n"
"--5.1/5.3兼容\n"
"if _VERSION == \"Lua 5.1\" then\n"
"    debugger_loadString = loadstring;\n"
"else\n"
"    debugger_loadString = load;\n"
"end\n"
"\n"
"--用户在控制台输入信息的环境变量\n"
"env = setmetatable({ }, {\n"
"    __index = function( _ , varName )\n"
"        local ret =  this.getWatchedVariable( varName, _G.LuaPanda.curStackId , false);\n"
"        return ret;\n"
"    end,\n"
"\n"
"    __newindex = function( _ , varName, newValue )\n"
"        this.setVariableValue( varName, _G.LuaPanda.curStackId, newValue);\n"
"    end\n"
"});\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 流程\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- 启动调试器\n"
"-- @host adapter端ip, 默认127.0.0.1\n"
"-- @port adapter端port ,默认8818\n"
"function this.start(host, port)\n"
"    host = tostring(host or \"127.0.0.1\") ;\n"
"    port = tonumber(port) or 8818;\n"
"    this.printToConsole(\"Debugger start. connect host:\" .. host .. \" port:\".. tostring(port), 1);\n"
"    if sock ~= nil then\n"
"        this.printToConsole(\"[Warning] 调试器已经启动，请不要再次调用start()\" , 1);\n"
"        return;\n"
"    end\n"
"\n"
"    --尝试初次连接\n"
"    this.changeRunState(runState.DISCONNECT);\n"
"    this.reGetSock();\n"
"    connectHost = host;\n"
"    connectPort = port;\n"
"    local sockSuccess = sock and sock:connect(connectHost, connectPort);\n"
"    if sockSuccess ~= nil then\n"
"        this.printToConsole(\"first connect success!\");\n"
"        this.connectSuccess();\n"
"    else\n"
"        this.printToConsole(\"first connect failed!\");\n"
"        this.changeHookState(hookState.DISCONNECT_HOOK);\n"
"    end\n"
"end\n"
"\n"
"-- 连接成功，开始初始化\n"
"function this.connectSuccess()\n"
"    this.changeRunState(runState.WAIT_CMD);\n"
"    this.printToConsole(\"connectSuccess\", 1);\n"
"    --设置初始状态\n"
"    local ret = this.debugger_wait_msg();\n"
"\n"
"    --获取debugger文件路径\n"
"    if DebuggerFileName == \"\" then\n"
"        local info = debug.getinfo(1, \"S\")\n"
"        for k,v in pairs(info) do\n"
"            if k == \"source\" then\n"
"                DebuggerFileName = v;\n"
"                this.printToVSCode(\"DebuggerFileName:\" .. tostring(DebuggerFileName));\n"
"\n"
"                if hookLib ~= nil then\n"
"                    hookLib.sync_debugger_path(DebuggerFileName);\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"    if DebuggerToolsName == \"\" then\n"
"        DebuggerToolsName = tools.getFileSource();\n"
"        if hookLib ~= nil then\n"
"            hookLib.sync_tools_path(DebuggerToolsName);\n"
"        end\n"
"    end\n"
"\n"
"    if ret == false then\n"
"        this.printToVSCode(\"[debugger error]初始化未完成, 建立连接但接收初始化消息失败。请更换端口重试\", 2);\n"
"        return;\n"
"    end\n"
"    this.printToVSCode(\"debugger init success\", 1);\n"
"\n"
"    this.changeHookState(hookState.ALL_HOOK);\n"
"    if hookLib == nil then\n"
"        --协程调试\n"
"        if coroutineCreate == nil and type(coroutine.create) == \"function\" then\n"
"            this.printToConsole(\"change coroutine.create\");\n"
"            coroutineCreate = coroutine.create;\n"
"            coroutine.create = function(...)\n"
"                local co =  coroutineCreate(...)\n"
"                table.insert(coroutinePool,  co);\n"
"                --运行状态下，创建协程即启动hook\n"
"                this.changeCoroutineHookState();\n"
"                return co;\n"
"            end\n"
"        else\n"
"            this.printToConsole(\"restart coroutine\");\n"
"            this.changeCoroutineHookState();\n"
"        end\n"
"    end\n"
"\n"
"end\n"
"\n"
"--重置数据\n"
"function this.clearData()\n"
"    OSType = nil;\n"
"    clibPath = nil;\n"
"    -- reset breaks\n"
"    breaks = {};\n"
"    pathFormatCache = {};\n"
"    this.breaks = breaks;\n"
"    if hookLib ~= nil then\n"
"        hookLib.sync_breakpoints(); --清空断点信息\n"
"        hookLib.clear_pathcache(); --清空路径缓存\n"
"    end\n"
"end\n"
"\n"
"--断开连接\n"
"function this.disconnect()\n"
"    this.printToConsole(\"Debugger disconnect\", 1);\n"
"    this.clearData()\n"
"    this.changeHookState( hookState.DISCONNECT_HOOK );\n"
"    stopConnectTime = os.time();\n"
"    this.changeRunState(runState.DISCONNECT);\n"
"\n"
"    if sock ~= nil then\n"
"        sock:close();\n"
"    end\n"
"    this.reGetSock();\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 调试器通用方法\n"
"-----------------------------------------------------------------------------\n"
"-- 返回断点信息\n"
"function this.getBreaks()\n"
"    return breaks;\n"
"end\n"
"\n"
"-- 返回路径相关信息\n"
"-- cwd:配置的工程路径  |  info[\"source\"]:通过 debug.getinfo 获得执行文件的路径  |  format：格式化后的文件路径\n"
"function this.getCWD()\n"
"    local ly = this.getSpecificFunctionStackLevel(lastRunFunction.func);\n"
"    if type(ly) ~= \"number\" then\n"
"        ly = 2;\n"
"    end\n"
"    local runSource = lastRunFunction[\"source\"];\n"
"    if runSource == nil and hookLib ~= nil then\n"
"        runSource = this.getPath(tostring(hookLib.get_last_source()));\n"
"    end\n"
"    local info = debug.getinfo(ly, \"S\");\n"
"    return \"cwd:      \"..cwd ..\"\\ngetinfo:  \".. info[\"source\"] .. \"\\nformat:   \" .. tostring(runSource) ;\n"
"end\n"
"\n"
"--返回版本号等配置\n"
"function this.getBaseInfo()\n"
"    local strTable = {};\n"
"    strTable[#strTable + 1] = \"Lua Ver:\" .. _VERSION .. \" | adapterVer:\" .. tostring(adapterVer) .. \" | Debugger Ver:\" .. tostring(debuggerVer);\n"
"    local moreInfoStr = \"\";\n"
"    if hookLib ~= nil then\n"
"        local clibVer, forluaVer = hookLib.sync_getLibVersion();\n"
"        local clibStr = forluaVer ~= nil and tostring(clibVer) .. \" for \" .. tostring(math.ceil(forluaVer)) or tostring(clibVer);\n"
"        strTable[#strTable + 1] = \" | hookLib Ver:\" .. clibStr;\n"
"        moreInfoStr = moreInfoStr .. \"说明: 已加载 libpdebug 库.\";\n"
"    else\n"
"        moreInfoStr = moreInfoStr .. \"说明: 未能加载 libpdebug 库。原因请使用 LuaPanda.doctor() 查看\";\n"
"    end\n"
"\n"
"    local outputIsUseLoadstring = false\n"
"    if type(isUseLoadstring) == \"number\" and isUseLoadstring == 1 then\n"
"        outputIsUseLoadstring = true;\n"
"    end\n"
"\n"
"    strTable[#strTable + 1] = \" | supportREPL:\".. tostring(outputIsUseLoadstring);\n"
"    strTable[#strTable + 1] = \" | useBase64EncodeString:\".. tostring(isNeedB64EncodeStr);\n"
"    strTable[#strTable + 1] = \" | codeEnv:\" .. tostring(OSType) .. '\\n';\n"
"    strTable[#strTable + 1] = moreInfoStr;\n"
"    if OSTypeErrTip ~= nil and OSTypeErrTip ~= '' then\n"
"        strTable[#strTable + 1] = '\\n' ..OSTypeErrTip;\n"
"    end\n"
"    return table.concat(strTable);\n"
"end\n"
"\n"
"--自动诊断当前环境的错误，并输出信息\n"
"function this.doctor()\n"
"    local strTable = {};\n"
"    if debuggerVer ~= adapterVer then\n"
"        strTable[#strTable + 1] = \"\\n- 建议更新版本\\nLuaPanda VSCode插件版本是\" ..  adapterVer .. \", LuaPanda.lua文件版本是\" ..  debuggerVer .. \"。建议检查并更新到最新版本。\";\n"
"        strTable[#strTable + 1] = \"\\n更新方式   : https://github.com/Tencent/LuaPanda/blob/master/Docs/Manual/update.md\";\n"
"        strTable[#strTable + 1] = \"\\nRelease版本: https://github.com/Tencent/LuaPanda/releases\";\n"
"    end\n"
"    --plibdebug\n"
"    if hookLib == nil then\n"
"        strTable[#strTable + 1] = \"\\n\\n- libpdebug 库没有加载\\n\";\n"
"        if userSetUseClib then\n"
"            --用户允许使用clib插件\n"
"            if isUserSetClibPath == true then\n"
"                --用户自设了clib地址\n"
"                strTable[#strTable + 1] = \"用户使用 LuaPanda.lua 中 clibPath 变量指定了 plibdebug 的位置: \" .. clibPath;\n"
"                if this.tryRequireClib(\"libpdebug\", clibPath) then\n"
"                    strTable[#strTable + 1] = \"\\n引用成功\";\n"
"                else\n"
"                    strTable[#strTable + 1] = \"\\n引用错误:\" .. loadclibErrReason;\n"
"                end\n"
"            else\n"
"                --使用默认clib地址\n"
"                local clibExt, platform;\n"
"                if OSType == \"Darwin\" then clibExt = \"/?.so;\"; platform = \"mac\";\n"
"                elseif OSType == \"Linux\" then clibExt = \"/?.so;\"; platform = \"linux\";\n"
"                else clibExt = \"/?.dll;\"; platform = \"win\";   end\n"
"                local lua_ver;\n"
"                if _VERSION == \"Lua 5.1\" then\n"
"                    lua_ver = \"501\";\n"
"                else\n"
"                    lua_ver = \"503\";\n"
"                end\n"
"                local x86Path = clibPath .. platform ..\"/x86/\".. lua_ver .. clibExt;\n"
"                local x64Path = clibPath .. platform ..\"/x86_64/\".. lua_ver .. clibExt;\n"
"\n"
"                strTable[#strTable + 1] = \"尝试引用x64库: \".. x64Path;\n"
"                if this.tryRequireClib(\"libpdebug\", x64Path) then\n"
"                    strTable[#strTable + 1] = \"\\n引用成功\";\n"
"                else\n"
"                    strTable[#strTable + 1] = \"\\n引用错误:\" .. loadclibErrReason;\n"
"                    strTable[#strTable + 1] = \"\\n尝试引用x86库: \".. x86Path;\n"
"                    if this.tryRequireClib(\"libpdebug\", x86Path) then\n"
"                        strTable[#strTable + 1] = \"\\n引用成功\";\n"
"                    else\n"
"                        strTable[#strTable + 1] = \"\\n引用错误:\" .. loadclibErrReason;\n"
"                    end\n"
"                end\n"
"            end\n"
"        else\n"
"            strTable[#strTable + 1] = \"原因是\" .. loadclibErrReason;\n"
"        end\n"
"    end\n"
"\n"
"    --path\n"
"    --尝试直接读当前getinfo指向的文件，看能否找到。如果能，提示正确，如果找不到，给出提示，建议玩家在这个文件中打一个断点\n"
"    --检查断点，文件和当前文件的不同，给出建议\n"
"    local runSource = lastRunFilePath;\n"
"    if hookLib ~= nil then\n"
"        runSource = this.getPath(tostring(hookLib.get_last_source()));\n"
"    end\n"
"    if runSource and runSource ~= \"\" then\n"
"        -- 读文件\n"
"        local isFileExist = this.fileExists(runSource);\n"
"        if not isFileExist then\n"
"            strTable[#strTable + 1] = \"\\n\\n- 路径存在问题\\n\";\n"
"            --解析路径，得到文件名，到断点路径中查这个文件名\n"
"            local pathArray = this.stringSplit(runSource, '/');\n"
"            --如果pathArray和断点能匹配上\n"
"            local fileMatch= false;\n"
"            for key, _ in pairs(this.getBreaks()) do\n"
"                if string.find(key, pathArray[#pathArray], 1, true) then\n"
"                    --和断点匹配了\n"
"                    fileMatch = true;\n"
"                    -- retStr = retStr .. \"\\n请对比如下路径:\\n\";\n"
"                    strTable[#strTable + 1] = this.getCWD();\n"
"                    strTable[#strTable + 1] = \"\\nfilepath: \" .. key;\n"
"                    if isAbsolutePath then\n"
"                        strTable[#strTable + 1] = \"\\n说明:从lua虚拟机获取到的是绝对路径，format使用getinfo路径。\";\n"
"                    else\n"
"                        strTable[#strTable + 1] = \"\\n说明:从lua虚拟机获取到的是相对路径，format来源于cwd+getinfo拼接。\";\n"
"                    end\n"
"                    strTable[#strTable + 1] = \"\\nfilepath是VSCode通过获取到的文件正确路径 , 对比format和filepath，调整launch.json中CWD，或改变VSCode打开文件夹的位置。使format和filepath一致即可。\\n如果format和filepath路径仅大小写不一致，设置launch.json中 pathCaseSensitivity:false 可忽略路径大小写\";\n"
"                end\n"
"            end\n"
"\n"
"            if fileMatch == false then\n"
"                 --未能和断点匹配\n"
"                 strTable[#strTable + 1] = \"\\n找不到文件:\"  .. runSource .. \", 请检查路径是否正确。\\n或者在VSCode文件\" .. pathArray[#pathArray] .. \"中打一个断点后，再执行一次doctor命令，查看路径分析结果。\";\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    --日志等级对性能的影响\n"
"    if logLevel < 1 or consoleLogLevel < 1 then\n"
"        strTable[#strTable + 1] = \"\\n\\n- 日志等级\\n\";\n"
"        if logLevel < 1 then\n"
"            strTable[#strTable + 1] = \"当前日志等级是\" ..  logLevel .. \", 会产生大量日志，降低调试速度。建议调整launch.json中logLevel:1\";\n"
"        end\n"
"        if consoleLogLevel < 1 then\n"
"            strTable[#strTable + 1] = \"当前console日志等级是\" ..  consoleLogLevel .. \", 过低的日志等级会降低调试速度，建议调整LuaPanda.lua文件头部consoleLogLevel=2\";\n"
"        end\n"
"    end\n"
"    \n"
"    if #strTable == 0 then\n"
"        strTable[#strTable + 1] = \"未检测出问题\";\n"
"    end\n"
"    return table.concat(strTable);\n"
"end\n"
"\n"
"function this.fileExists(path)\n"
"    local f=io.open(path,\"r\");\n"
"    if f~= nil then io.close(f) return true else return false end\n"
" end\n"
"\n"
"--返回一些信息，帮助用户定位问题\n"
"function this.getInfo()\n"
"    --用户设置项\n"
"    local strTable = {};\n"
"    strTable[#strTable + 1] = \"\\n- Base Info: \\n\";\n"
"    strTable[#strTable + 1] = this.getBaseInfo();\n"
"    --已经加载C库，x86/64  未能加载，原因\n"
"    strTable[#strTable + 1] = \"\\n\\n- User Setting: \\n\";\n"
"    strTable[#strTable + 1] = \"stopOnEntry:\" .. tostring(stopOnEntry) .. ' | ';\n"
"    -- strTable[#strTable + 1] = \"luaFileExtension:\" .. luaFileExtension .. ' | ';\n"
"    strTable[#strTable + 1] = \"logLevel:\" .. logLevel .. ' | ' ;\n"
"    strTable[#strTable + 1] = \"consoleLogLevel:\" .. consoleLogLevel .. ' | ';\n"
"    strTable[#strTable + 1] = \"pathCaseSensitivity:\" .. pathCaseSensitivity .. ' | ';\n"
"    strTable[#strTable + 1] = \"attachMode:\".. tostring(openAttachMode).. ' | ';\n"
"\n"
"    if userSetUseClib then\n"
"        strTable[#strTable + 1] = \"useCHook:true\";\n"
"    else\n"
"        strTable[#strTable + 1] = \"useCHook:false\";\n"
"    end\n"
"\n"
"    if logLevel == 0 or consoleLogLevel == 0 then\n"
"        strTable[#strTable + 1] = \"\\n说明:日志等级过低，会影响执行效率。请调整logLevel和consoleLogLevel值 >= 1\";\n"
"    end\n"
"\n"
"    strTable[#strTable + 1] = \"\\n\\n- Path Info: \\n\";\n"
"    strTable[#strTable + 1] = \"clibPath: \" .. tostring(clibPath) .. '\\n';\n"
"    strTable[#strTable + 1] = \"debugger: \" .. this.getPath(DebuggerFileName) .. '\\n';\n"
"    strTable[#strTable + 1] = this.getCWD();\n"
"    if isAbsolutePath then\n"
"        strTable[#strTable + 1] = \"\\n说明:从lua虚拟机获取到的是绝对路径，format使用getinfo路径。\" .. winDiskSymbolTip;\n"
"    else\n"
"        strTable[#strTable + 1] = \"\\n说明:从lua虚拟机获取到的是相对路径，format来源于cwd+getinfo拼接。如format文件路径错误请尝试调整cwd或改变VSCode打开文件夹的位置。也可以在format对应的文件下打一个断点，调整直到format和Breaks Info中断点路径完全一致。\" .. winDiskSymbolTip;\n"
"    end\n"
"\n"
"    if pathErrTip ~= nil and pathErrTip ~= '' then\n"
"        strTable[#strTable + 1] = '\\n' .. pathErrTip;\n"
"    end\n"
"\n"
"    strTable[#strTable + 1] = \"\\n\\n- Breaks Info: \\n\";\n"
"    strTable[#strTable + 1] = this.printTable(this.getBreaks(), \"breaks\");\n"
"    return table.concat(strTable);\n"
"end\n"
"\n"
"--判断是否在协程中\n"
"function this.isInMain()\n"
"    return isInMainThread;\n"
"end\n"
"\n"
"--添加路径，尝试引用库。完成后把cpath还原，返回引用结果true/false\n"
"-- @libName 库名\n"
"-- path lib的cpath路径\n"
"function this.tryRequireClib(libName , libPath)\n"
"    this.printToVSCode(\"tryRequireClib search : [\" .. libName .. \"] in \"..libPath);\n"
"    local savedCpath = package.cpath;\n"
"    package.cpath = package.cpath  .. ';' .. libPath;\n"
"    this.printToVSCode(\"package.cpath:\" .. package.cpath);\n"
"    local status, err = pcall(function() hookLib = require(libName) end);\n"
"    if status then\n"
"        if type(hookLib) == \"table\" and this.getTableMemberNum(hookLib) > 0 then\n"
"            this.printToVSCode(\"tryRequireClib success : [\" .. libName .. \"] in \"..libPath);\n"
"            package.cpath = savedCpath;\n"
"            return true;\n"
"        else\n"
"            loadclibErrReason = \"tryRequireClib fail : require success, but member function num <= 0; [\" .. libName .. \"] in \"..libPath;\n"
"            this.printToVSCode(loadclibErrReason);\n"
"            hookLib = nil;\n"
"            package.cpath = savedCpath;\n"
"            return false;\n"
"        end\n"
"    else\n"
"        -- 此处考虑到tryRequireClib会被调用两次，日志级别设置为0，防止输出不必要的信息。\n"
"        loadclibErrReason = err;\n"
"        this.printToVSCode(\"[Require clib error]: \" .. err, 0);\n"
"    end\n"
"    package.cpath = savedCpath;\n"
"    return false\n"
"end\n"
"------------------------字符串处理-------------------------\n"
"-- 倒序查找字符串 a.b/c查找/ , 返回4\n"
"-- @str 被查找的长串\n"
"-- @subPattern 查找的子串, 也可以是pattern\n"
"-- @plain plane text / pattern\n"
"-- @return 未找到目标串返回nil. 否则返回倒序找到的字串位置\n"
"function this.revFindString(str, subPattern, plain)\n"
"    local revStr = string.reverse(str);\n"
"    local _, idx = string.find(revStr, subPattern, 1, plain);\n"
"    if idx == nil then return nil end;\n"
"    return string.len(revStr) - idx + 1;\n"
"end\n"
"\n"
"-- 反序裁剪字符串 如:print(subString(\"a.b/c\", \"/\"))输出c\n"
"-- @return 未找到目标串返回nil. 否则返回被裁剪后的字符串\n"
"function this.revSubString(str, subStr, plain)\n"
"    local idx = this.revFindString(str, subStr, plain)\n"
"    if idx == nil then return nil end;\n"
"    return string.sub(str, idx + 1, str.length)\n"
"end\n"
"\n"
"-- 把字符串按reps分割成并放入table\n"
"-- @str 目标串\n"
"-- @reps 分割符。注意这个分隔符是一个pattern\n"
"function this.stringSplit( str, separator )\n"
"    local retStrTable = {}\n"
"    string.gsub(str, '[^' .. separator ..']+', function ( word )\n"
"        table.insert(retStrTable, word)\n"
"    end)\n"
"    return retStrTable;\n"
"end\n"
"\n"
"-- 保存CallbackId(通信序列号)\n"
"function this.setCallbackId( id )\n"
"    if id ~= nil and  id ~= \"0\" then\n"
"        recCallbackId = tostring(id);\n"
"    end\n"
"end\n"
"\n"
"-- 读取CallbackId(通信序列号)。读取后记录值将被置空\n"
"function this.getCallbackId()\n"
"    if recCallbackId == nil then\n"
"        recCallbackId = \"0\";\n"
"    end\n"
"    local id = recCallbackId;\n"
"    recCallbackId = \"0\";\n"
"    return id;\n"
"end\n"
"\n"
"-- reference from https://www.lua.org/pil/20.1.html\n"
"function this.trim (s)\n"
"    return (string.gsub(s, \"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"--返回table中成员数量(数字key和非数字key之和)\n"
"-- @t 目标table\n"
"-- @return 元素数量\n"
"function this.getTableMemberNum(t)\n"
"    local retNum = 0;\n"
"    if type(t) ~= \"table\" then\n"
"        this.printToVSCode(\"[debugger Error] getTableMemberNum get \"..tostring(type(t)), 2)\n"
"        return retNum;\n"
"    end\n"
"    for k,v in pairs(t) do\n"
"        retNum = retNum + 1;\n"
"    end\n"
"    return retNum;\n"
"end\n"
"\n"
"-- 生成一个消息Table\n"
"function this.getMsgTable(cmd ,callbackId)\n"
"    callbackId = callbackId or 0;\n"
"    local msgTable = {};\n"
"    msgTable[\"cmd\"] = cmd;\n"
"    msgTable[\"callbackId\"] = callbackId;\n"
"    msgTable[\"info\"] = {};\n"
"    return msgTable;\n"
"end\n"
"\n"
"function this.printTable(tab, name)\n"
"    local sTable = tools.serializeTable(tab, name);\n"
"    return sTable;\n"
"end\n"
"------------------------日志打印相关-------------------------\n"
"-- 把日志打印在VSCode端\n"
"-- @str: 日志内容\n"
"-- @printLevel: all(0)/info(1)/error(2)\n"
"-- @type: 0:vscode console  1:vscode tip\n"
"function this.printToVSCode(str, printLevel, type)\n"
"    type = type or 0;\n"
"    printLevel = printLevel or 0;\n"
"    if currentRunState == runState.DISCONNECT or logLevel > printLevel then\n"
"        return;\n"
"    end\n"
"\n"
"    local sendTab = {};\n"
"    sendTab[\"callbackId\"] = \"0\";\n"
"    if type == 0 then\n"
"        sendTab[\"cmd\"] = \"log\";\n"
"    else\n"
"        sendTab[\"cmd\"] =  \"tip\";\n"
"    end\n"
"    sendTab[\"info\"] = {};\n"
"    sendTab[\"info\"][\"logInfo\"] = tostring(str);\n"
"    this.sendMsg(sendTab);\n"
"end\n"
"\n"
"-- 把日志打印在控制台\n"
"-- @str: 日志内容\n"
"-- @printLevel: all(0)/info(1)/error(2)\n"
"function this.printToConsole(str, printLevel)\n"
"    printLevel = printLevel or 0;\n"
"    if consoleLogLevel > printLevel then\n"
"        return;\n"
"    end\n"
"    print(\"[LuaPanda] \".. tostring(str));\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 提升兼容性方法\n"
"-----------------------------------------------------------------------------\n"
"--生成平台无关的路径。\n"
"--return:nil(error)/path\n"
"function this.genUnifiedPath(path)\n"
"    if path == \"\" or path == nil then\n"
"        return nil;\n"
"    end\n"
"    --大小写不敏感时，路径全部转为小写\n"
"    if pathCaseSensitivity == 0 then\n"
"        path = string.lower(path);\n"
"    end\n"
"    --统一路径全部替换成/\n"
"    path = string.gsub(path, [[\\]], \"/\");\n"
"    --处理 /../   /./\n"
"    local pathTab = this.stringSplit(path, '/');\n"
"    local newPathTab = {};\n"
"    for k, v in ipairs(pathTab) do\n"
"        if v == '.' then\n"
"            --continue\n"
"        elseif v == \"..\" and #newPathTab >= 1 and newPathTab[#newPathTab]:sub(2,2) ~= ':' then\n"
"            --newPathTab有元素，最后一项不是X:\n"
"            table.remove(newPathTab);\n"
"        else\n"
"            table.insert(newPathTab, v);\n"
"        end\n"
"    end\n"
"    --重新拼合后如果是mac路径第一位是/\n"
"    local newpath = table.concat(newPathTab, '/');\n"
"    if path:sub(1,1) == '/' then\n"
"        newpath = '/'.. newpath;\n"
"    end\n"
"\n"
"    --win下按照winDiskSymbolUpper的设置修改盘符大小\n"
"    if \"Windows_NT\" == OSType then\n"
"        if winDiskSymbolUpper then\n"
"            newpath = newpath:gsub(\"^%a:\", string.upper);\n"
"            winDiskSymbolTip = \"路径中Windows盘符已转为大写。\"\n"
"        else\n"
"            newpath = newpath:gsub(\"^%a:\", string.lower);\n"
"            winDiskSymbolTip = \"路径中Windows盘符已转为小写。\"\n"
"        end\n"
"    end\n"
"\n"
"    return newpath;\n"
"end\n"
"\n"
"function this.getPathFromCache(source)\n"
"    return  pathFormatCache[source];\n"
"end\n"
"\n"
"function this.setPathToCache(source, dest)\n"
"    pathFormatCache[source] = dest;\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"-- 内存相关\n"
"-----------------------------------------------------------------------------\n"
"function this.sendLuaMemory()\n"
"    local luaMem = collectgarbage(\"count\");\n"
"    local sendTab = {};\n"
"    sendTab[\"callbackId\"] = \"0\";\n"
"    sendTab[\"cmd\"] = \"refreshLuaMemory\";\n"
"    sendTab[\"info\"] = {};\n"
"    sendTab[\"info\"][\"memInfo\"] = tostring(luaMem);\n"
"    this.sendMsg(sendTab);\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 网络相关方法\n"
"-----------------------------------------------------------------------------\n"
"--刷新socket\n"
"function this.reGetSock()\n"
"    if sock ~= nil then\n"
"        pcall(function() sock:close() end);\n"
"    end\n"
"    --call ue4 luasocket\n"
"    sock = lua_extension and lua_extension.luasocket and lua_extension.luasocket().tcp();\n"
"    if sock == nil then\n"
"        --call u3d luasocket\n"
"       if pcall(function() sock =  require(\"socket.core\").tcp(); end) then\n"
"            this.printToConsole(\"reGetSock success\");\n"
"            sock:settimeout(connectTimeoutSec);\n"
"       else\n"
"            --call custom function to get socket\n"
"            if customGetSocketInstance and pcall( function() sock =  customGetSocketInstance(); end ) then\n"
"                this.printToConsole(\"reGetSock custom success\");\n"
"                sock:settimeout(connectTimeoutSec);      \n"
"            else\n"
"                this.printToConsole(\"[Error] reGetSock fail\", 2);\n"
"            end\n"
"       end\n"
"    else\n"
"        --set ue4 luasocket\n"
"        this.printToConsole(\"reGetSock ue4 success\");\n"
"        sock:settimeout(connectTimeoutSec);\n"
"    end\n"
"end\n"
"\n"
"-- 定时(以函数return为时机) 进行attach连接\n"
"function this.reConnect()\n"
"    if currentHookState == hookState.DISCONNECT_HOOK then\n"
"        if os.time() - stopConnectTime < attachInterval then\n"
"            this.printToConsole(\"Reconnect time less than 1s\");\n"
"            this.printToConsole(\"os.time:\".. os.time() .. \" | stopConnectTime:\" ..stopConnectTime);\n"
"            return 1;\n"
"        end\n"
"\n"
"        if sock == nil then\n"
"            this.reGetSock();\n"
"        end\n"
"\n"
"        local sockSuccess, status = sock:connect(connectHost, connectPort);\n"
"        if sockSuccess == 1 or status == \"already connected\" then\n"
"            this.printToConsole(\"reconnect success\");\n"
"            this.connectSuccess();\n"
"        else\n"
"            this.printToConsole(\"reconnect failed . retCode:\" .. tostring(sockSuccess) .. \"  status:\" .. status);\n"
"            stopConnectTime = os.time();\n"
"        end\n"
"        return 1;\n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"-- 向adapter发消息\n"
"-- @sendTab 消息体table\n"
"function this.sendMsg( sendTab )\n"
"    if isNeedB64EncodeStr and sendTab[\"info\"] ~= nil then\n"
"        for _, v in ipairs(sendTab[\"info\"]) do\n"
"            if v[\"type\"] == \"string\" then\n"
"                v[\"value\"] = tools.base64encode(v[\"value\"])\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    local sendStr = json.encode(sendTab);\n"
"    if currentRunState == runState.DISCONNECT then\n"
"        this.printToConsole(\"[debugger error] disconnect but want sendMsg:\" .. sendStr, 2);\n"
"        this.disconnect();\n"
"        return;\n"
"    end\n"
"\n"
"    local succ,err;\n"
"    if pcall(function() succ,err = sock:send(sendStr..TCPSplitChar..\"\\n\"); end) then\n"
"        if succ == nil then\n"
"            if err == \"closed\" then\n"
"                this.disconnect();\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- 处理 收到的消息\n"
"-- @dataStr 接收的消息json\n"
"function this.dataProcess( dataStr )\n"
"    this.printToVSCode(\"debugger get:\"..dataStr);\n"
"    local dataTable = json.decode(dataStr);\n"
"    if dataTable == nil then\n"
"        this.printToVSCode(\"[error] Json is error\", 2);\n"
"        return;\n"
"    end\n"
"\n"
"    if dataTable.callbackId ~= \"0\" then\n"
"        this.setCallbackId(dataTable.callbackId);\n"
"    end\n"
"\n"
"    if dataTable.cmd == \"continue\" then\n"
"        this.changeRunState(runState.RUN);\n"
"        local msgTab = this.getMsgTable(\"continue\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"\n"
"    elseif dataTable.cmd == \"stopOnStep\" then\n"
"        this.changeRunState(runState.STEPOVER);\n"
"        local msgTab = this.getMsgTable(\"stopOnStep\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"\n"
"    elseif dataTable.cmd == \"stopOnStepIn\" then\n"
"        this.changeRunState(runState.STEPIN);\n"
"        local msgTab = this.getMsgTable(\"stopOnStepIn\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"\n"
"    elseif dataTable.cmd == \"stopOnStepOut\" then\n"
"        this.changeRunState(runState.STEPOUT);\n"
"        local msgTab = this.getMsgTable(\"stopOnStepOut\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"\n"
"    elseif dataTable.cmd == \"setBreakPoint\" then\n"
"        this.printToVSCode(\"dataTable.cmd == setBreakPoint\");\n"
"        local bkPath = dataTable.info.path;\n"
"        bkPath = this.genUnifiedPath(bkPath);\n"
"\n"
"        this.printToVSCode(\"setBreakPoint path:\"..tostring(bkPath));\n"
"        breaks[bkPath] = dataTable.info.bks;\n"
"        --save\n"
"        for k, v in pairs(breaks) do\n"
"            if next(v) == nil then\n"
"                breaks[k] = nil;\n"
"            end\n"
"        end\n"
"        --sync breaks to c\n"
"        if hookLib ~= nil then\n"
"            hookLib.sync_breakpoints();\n"
"        end\n"
"\n"
"        if currentRunState ~= runState.WAIT_CMD then\n"
"            if hookLib == nil then\n"
"                local fileBP, G_BP =this.checkHasBreakpoint(lastRunFilePath);\n"
"                if fileBP == false then\n"
"                    if G_BP == true then\n"
"                        this.changeHookState(hookState.MID_HOOK);\n"
"                    else\n"
"                        this.changeHookState(hookState.LITE_HOOK);\n"
"                    end\n"
"                else\n"
"                    this.changeHookState(hookState.ALL_HOOK);\n"
"                end\n"
"            end\n"
"        else\n"
"            local msgTab = this.getMsgTable(\"setBreakPoint\", this.getCallbackId());\n"
"            this.sendMsg(msgTab);\n"
"            return;\n"
"        end\n"
"        --其他时机收到breaks消息\n"
"        local msgTab = this.getMsgTable(\"setBreakPoint\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"        -- 打印调试信息\n"
"        this.printToVSCode(\"LuaPanda.getInfo()\\n\" .. this.getInfo())\n"
"        this.debugger_wait_msg();\n"
"    elseif dataTable.cmd == \"setVariable\" then\n"
"        if currentRunState == runState.STOP_ON_ENTRY or\n"
"            currentRunState == runState.HIT_BREAKPOINT or\n"
"            currentRunState == runState.STEPOVER_STOP or\n"
"            currentRunState == runState.STEPIN_STOP or\n"
"            currentRunState == runState.STEPOUT_STOP then\n"
"            local msgTab = this.getMsgTable(\"setVariable\", this.getCallbackId());\n"
"            local varRefNum = tonumber(dataTable.info.varRef);\n"
"            local newValue = tostring(dataTable.info.newValue);\n"
"            local needFindVariable = true;    --如果变量是基础类型，直接赋值，needFindVariable = false; 如果变量是引用类型，needFindVariable = true\n"
"            local varName = tostring(dataTable.info.varName);\n"
"            -- 根据首末含有\" ' 判断 newValue 是否是字符串\n"
"            local first_chr = string.sub(newValue, 1, 1);\n"
"            local end_chr = string.sub(newValue, -1, -1);\n"
"            if first_chr == end_chr then\n"
"                if first_chr == \"'\" or first_chr == '\"' then\n"
"                    newValue = string.sub(newValue, 2, -2);\n"
"                    needFindVariable = false;\n"
"                end\n"
"            end\n"
"            --数字，nil，false，true的处理\n"
"            if newValue == \"nil\" and needFindVariable == true  then newValue = nil; needFindVariable = false;\n"
"            elseif newValue == \"true\" and needFindVariable == true then newValue = true; needFindVariable = false;\n"
"            elseif newValue == \"false\" and needFindVariable == true then newValue = false; needFindVariable = false;\n"
"            elseif tonumber(newValue) and needFindVariable == true then newValue = tonumber(newValue); needFindVariable = false;\n"
"            end\n"
"\n"
"            -- 如果新值是基础类型，则不需边历\n"
"            if dataTable.info.stackId ~= nil and tonumber(dataTable.info.stackId) ~= nil and tonumber(dataTable.info.stackId) > 1 then\n"
"                this.curStackId = tonumber(dataTable.info.stackId);\n"
"            else\n"
"                this.printToVSCode(\"未能获取到堆栈层级，默认使用 this.curStackId;\")\n"
"            end\n"
"\n"
"            if varRefNum < 10000 then\n"
"                -- 如果修改的是一个 引用变量，那么可直接赋值。但还是要走变量查询过程。查找和赋值过程都需要steakId。 目前给引用变量赋值Object，steak可能有问题\n"
"                msgTab.info = this.createSetValueRetTable(varName, newValue, needFindVariable, this.curStackId, variableRefTab[varRefNum]);\n"
"            else\n"
"                -- 如果修改的是一个基础类型\n"
"                local setLimit; --设置检索变量的限定区域\n"
"                if varRefNum >= 10000 and varRefNum < 20000 then setLimit = \"local\";\n"
"                elseif varRefNum >= 20000 and varRefNum < 30000 then setLimit = \"global\";\n"
"                elseif varRefNum >= 30000 then setLimit = \"upvalue\";\n"
"                end\n"
"                msgTab.info = this.createSetValueRetTable(varName, newValue, needFindVariable, this.curStackId, nil, setLimit);\n"
"            end\n"
"\n"
"            this.sendMsg(msgTab);\n"
"            this.debugger_wait_msg();\n"
"        end\n"
"\n"
"    elseif dataTable.cmd == \"getVariable\" then\n"
"        --仅在停止时处理消息，其他时刻收到此消息，丢弃\n"
"        if currentRunState == runState.STOP_ON_ENTRY or\n"
"        currentRunState == runState.HIT_BREAKPOINT or\n"
"        currentRunState == runState.STEPOVER_STOP or\n"
"        currentRunState == runState.STEPIN_STOP or\n"
"        currentRunState == runState.STEPOUT_STOP then\n"
"            --发送变量给游戏，并保持之前的状态,等待再次接收数据\n"
"            --dataTable.info.varRef  10000~20000局部变量\n"
"            --                       20000~30000全局变量\n"
"            --                       30000~     upvalue\n"
"            -- 1000~2000局部变量的查询，2000~3000全局，3000~4000upvalue\n"
"            local msgTab = this.getMsgTable(\"getVariable\", this.getCallbackId());\n"
"            local varRefNum = tonumber(dataTable.info.varRef);\n"
"            if varRefNum < 10000 then\n"
"                --查询变量, 此时忽略 stackId\n"
"                local varTable = this.getVariableRef(dataTable.info.varRef, true);\n"
"                msgTab.info = varTable;\n"
"            elseif varRefNum >= 10000 and varRefNum < 20000 then\n"
"                --局部变量\n"
"                if dataTable.info.stackId ~= nil and tonumber(dataTable.info.stackId) > 1 then\n"
"                    this.curStackId = tonumber(dataTable.info.stackId);\n"
"                    if type(currentCallStack[this.curStackId - 1]) ~= \"table\" or  type(currentCallStack[this.curStackId - 1].func) ~= \"function\" then\n"
"                        local str = \"getVariable getLocal currentCallStack \" .. this.curStackId - 1   .. \" Error\\n\" .. this.printTable(currentCallStack, \"currentCallStack\");\n"
"                        this.printToVSCode(str, 2);\n"
"                        msgTab.info = {};\n"
"                    else\n"
"                        local stackId = this.getSpecificFunctionStackLevel(currentCallStack[this.curStackId - 1].func); --去除偏移量\n"
"                        local varTable = this.getVariable(stackId, true);\n"
"                        msgTab.info = varTable;\n"
"                    end\n"
"                end\n"
"\n"
"            elseif varRefNum >= 20000 and varRefNum < 30000 then\n"
"                --全局变量\n"
"                local varTable = this.getGlobalVariable();\n"
"                msgTab.info = varTable;\n"
"            elseif varRefNum >= 30000 then\n"
"                --upValue\n"
"                if dataTable.info.stackId ~= nil and tonumber(dataTable.info.stackId) > 1 then\n"
"                    this.curStackId = tonumber(dataTable.info.stackId);\n"
"                    if type(currentCallStack[this.curStackId - 1]) ~= \"table\" or  type(currentCallStack[this.curStackId - 1].func) ~= \"function\" then\n"
"                        local str = \"getVariable getUpvalue currentCallStack \" .. this.curStackId - 1   .. \" Error\\n\" .. this.printTable(currentCallStack, \"currentCallStack\");\n"
"                        this.printToVSCode(str, 2);\n"
"                        msgTab.info = {};\n"
"                    else\n"
"                        local varTable = this.getUpValueVariable(currentCallStack[this.curStackId - 1 ].func, true);\n"
"                        msgTab.info = varTable;\n"
"                    end\n"
"                end\n"
"            end\n"
"            this.sendMsg(msgTab);\n"
"            this.debugger_wait_msg();\n"
"        end\n"
"    elseif dataTable.cmd == \"initSuccess\" then\n"
"        --初始化会传过来一些变量，这里记录这些变量\n"
"        --Base64\n"
"        if dataTable.info.isNeedB64EncodeStr == \"true\" then\n"
"            isNeedB64EncodeStr = true;\n"
"        else\n"
"            isNeedB64EncodeStr = false;\n"
"        end\n"
"        --path\n"
"        luaFileExtension = dataTable.info.luaFileExtension\n"
"        local TempFilePath = dataTable.info.TempFilePath;\n"
"        if TempFilePath:sub(-1, -1) == [[\\]] or TempFilePath:sub(-1, -1) == [[/]] then\n"
"            TempFilePath = TempFilePath:sub(1, -2);\n"
"        end\n"
"        TempFilePath_luaString = TempFilePath;\n"
"        cwd = this.genUnifiedPath(dataTable.info.cwd);\n"
"        --logLevel\n"
"        logLevel = tonumber(dataTable.info.logLevel) or 1;\n"
"        --OS type\n"
"        if nil == OSType then\n"
"            --用户未主动设置OSType, 接收VSCode传来的数据\n"
"            if type(dataTable.info.OSType) == \"string\" then \n"
"                OSType = dataTable.info.OSType;\n"
"            else\n"
"                OSType = \"Windows_NT\";\n"
"                OSTypeErrTip = \"未能检测出OSType, 可能是node os库未能加载，系统使用默认设置Windows_NT\"\n"
"            end\n"
"        else\n"
"            --用户自设OSType, 使用用户的设置\n"
"        end\n"
"\n"
"        --检测用户是否自设了clib路径\n"
"        isUserSetClibPath = false;\n"
"        if nil == clibPath then\n"
"            --用户未设置clibPath, 接收VSCode传来的数据\n"
"            if type(dataTable.info.clibPath) == \"string\" then  \n"
"                clibPath = dataTable.info.clibPath;\n"
"            else \n"
"                clibPath = \"\"; \n"
"                pathErrTip = \"未能正确获取libpdebug库所在位置, 可能无法加载libpdebug库。\";\n"
"            end\n"
"        else\n"
"            --用户自设clibPath\n"
"            isUserSetClibPath = true;\n"
"        end\n"
"\n"
"        if  tostring(dataTable.info.pathCaseSensitivity) == \"false\" then\n"
"            pathCaseSensitivity =  0;\n"
"        else\n"
"            pathCaseSensitivity =  1;\n"
"        end\n"
"\n"
"        --查找c++的hook库是否存在\n"
"        if tostring(dataTable.info.useCHook) == \"true\" then\n"
"            userSetUseClib = true;      --用户确定使用clib\n"
"            if isUserSetClibPath == true then   --如果用户自设了clib路径\n"
"                if luapanda_chook ~= nil then\n"
"                    hookLib = luapanda_chook;\n"
"                else\n"
"                    if not(this.tryRequireClib(\"libpdebug\", clibPath)) then\n"
"                        this.printToVSCode(\"Require clib failed, use Lua to continue debug, use LuaPanda.doctor() for more information.\", 1);\n"
"                    end\n"
"                end\n"
"            else\n"
"                local clibExt, platform;\n"
"                if OSType == \"Darwin\" then clibExt = \"/?.so;\"; platform = \"mac\";\n"
"                elseif OSType == \"Linux\" then clibExt = \"/?.so;\"; platform = \"linux\";\n"
"                else clibExt = \"/?.dll;\"; platform = \"win\";   end\n"
"\n"
"                local lua_ver;\n"
"                if _VERSION == \"Lua 5.1\" then\n"
"                    lua_ver = \"501\";\n"
"                else\n"
"                    lua_ver = \"503\";\n"
"                end\n"
"\n"
"                local x86Path = clibPath.. platform ..\"/x86/\".. lua_ver .. clibExt;\n"
"                local x64Path = clibPath.. platform ..\"/x86_64/\".. lua_ver .. clibExt;\n"
"\n"
"                if luapanda_chook ~= nil then\n"
"                    hookLib = luapanda_chook;\n"
"                else\n"
"                    if not(this.tryRequireClib(\"libpdebug\", x64Path) or this.tryRequireClib(\"libpdebug\", x86Path)) then\n"
"                        this.printToVSCode(\"Require clib failed, use Lua to continue debug, use LuaPanda.getInfo() for more information.\", 1);\n"
"                    end\n"
"                end\n"
"            end\n"
"        else\n"
"            userSetUseClib = false;\n"
"        end\n"
"\n"
"        --adapter版本信息\n"
"        adapterVer = tostring(dataTable.info.adapterVersion);\n"
"        local msgTab = this.getMsgTable(\"initSuccess\", this.getCallbackId());\n"
"        --回传是否使用了lib，是否有loadstring函数\n"
"        local isUseHookLib = 0;\n"
"        if hookLib ~= nil then\n"
"            isUseHookLib = 1;\n"
"            --同步数据给c hook\n"
"            hookLib.sync_config(logLevel, pathCaseSensitivity);\n"
"            hookLib.sync_tempfile_path(TempFilePath_luaString)\n"
"            hookLib.sync_cwd(cwd);\n"
"            hookLib.sync_file_ext(luaFileExtension);\n"
"        end\n"
"        --detect LoadString\n"
"        isUseLoadstring = 0;\n"
"        if debugger_loadString ~= nil and type(debugger_loadString) == \"function\" then\n"
"            if(pcall(debugger_loadString(\"return 0\"))) then\n"
"                isUseLoadstring = 1;\n"
"            end\n"
"        end\n"
"        local tab = { debuggerVer = tostring(debuggerVer) , UseHookLib = tostring(isUseHookLib) , UseLoadstring = tostring(isUseLoadstring), isNeedB64EncodeStr = tostring(isNeedB64EncodeStr) };\n"
"        msgTab.info  = tab;\n"
"        this.sendMsg(msgTab);\n"
"        --上面getBK中会判断当前状态是否WAIT_CMD, 所以最后再切换状态。\n"
"        stopOnEntry = dataTable.info.stopOnEntry;\n"
"        if dataTable.info.stopOnEntry == \"true\" then\n"
"            this.changeRunState(runState.STOP_ON_ENTRY);   --停止在STOP_ON_ENTRY再接收breaks消息\n"
"        else\n"
"            this.debugger_wait_msg(1);  --等待1s bk消息 如果收到或超时(没有断点)就开始运行\n"
"            this.changeRunState(runState.RUN);\n"
"        end\n"
"\n"
"    elseif dataTable.cmd == \"getWatchedVariable\" then\n"
"        local msgTab = this.getMsgTable(\"getWatchedVariable\", this.getCallbackId());\n"
"        local stackId = tonumber(dataTable.info.stackId);\n"
"        --loadstring系统函数, watch插件加载\n"
"        if isUseLoadstring == 1 then\n"
"            --使用loadstring\n"
"            this.curStackId = stackId;\n"
"            local retValue = this.processWatchedExp(dataTable.info);\n"
"            msgTab.info = retValue\n"
"            this.sendMsg(msgTab);\n"
"            this.debugger_wait_msg();\n"
"            return;\n"
"        else\n"
"            --旧的查找方式\n"
"            local wv =  this.getWatchedVariable(dataTable.info.varName, stackId, true);\n"
"            if wv ~= nil then\n"
"                msgTab.info = wv;\n"
"            end\n"
"            this.sendMsg(msgTab);\n"
"            this.debugger_wait_msg();\n"
"        end\n"
"    elseif dataTable.cmd == \"stopRun\" then\n"
"        --停止hook，已不在处理任何断点信息，也就不会产生日志等。发送消息后等待前端主动断开连接\n"
"        local msgTab = this.getMsgTable(\"stopRun\", this.getCallbackId());\n"
"        this.sendMsg(msgTab);\n"
"        this.disconnect();\n"
"    elseif \"LuaGarbageCollect\" == dataTable.cmd then\n"
"        this.printToVSCode(\"collect garbage!\");\n"
"        collectgarbage(\"collect\");\n"
"        --回收后刷一下内存\n"
"        this.sendLuaMemory();\n"
"        this.debugger_wait_msg();\n"
"    elseif \"runREPLExpression\" == dataTable.cmd then\n"
"        this.curStackId = tonumber(dataTable.info.stackId);\n"
"        local retValue = this.processExp(dataTable.info);\n"
"        local msgTab = this.getMsgTable(\"runREPLExpression\", this.getCallbackId());\n"
"        msgTab.info = retValue\n"
"        this.sendMsg(msgTab);\n"
"        this.debugger_wait_msg();\n"
"    else\n"
"    end\n"
"end\n"
"\n"
"-- 变量赋值的处理函数。基本逻辑是先从当前栈帧（curStackId）中取 newValue 代表的变量，找到之后再把找到的值通过setVariableValue写回。\n"
"-- @varName             被设置值的变量名\n"
"-- @newValue            新值的名字，它是一个string\n"
"-- @needFindVariable    是否需要查找引用变量。（用户输入的是否是一个Object）\n"
"-- @curStackId          当前栈帧（查找和变量赋值用）\n"
"-- @assigndVar          被直接赋值（省去查找过程）\n"
"-- @setLimit            赋值时的限制范围（local upvalue global）\n"
"function this.createSetValueRetTable(varName, newValue, needFindVariable, curStackId,  assigndVar , setLimit)\n"
"    local info;\n"
"    local getVarRet;\n"
"    -- needFindVariable == true，则使用getWatchedVariable处理（可选, 用来支持 a = b (b为变量的情况)）。\n"
"    if needFindVariable == false then\n"
"        getVarRet = {};\n"
"        getVarRet[1] = {variablesReference = 0, value = newValue, name = varName, type = type(newValue)};\n"
"    else\n"
"        getVarRet =  this.getWatchedVariable( tostring(newValue), curStackId, true);\n"
"    end\n"
"    if getVarRet ~= nil then\n"
"        -- newValue赋变量真实值\n"
"        local realVarValue;\n"
"        local displayVarValue = getVarRet[1].value;\n"
"        if needFindVariable == true then\n"
"            if tonumber(getVarRet[1].variablesReference) > 0 then\n"
"                realVarValue = variableRefTab[tonumber(getVarRet[1].variablesReference)];\n"
"            else\n"
"                if getVarRet[1].type == 'number' then realVarValue = tonumber(getVarRet[1].value) end\n"
"                if getVarRet[1].type == 'string' then\n"
"                    realVarValue = tostring(getVarRet[1].value);\n"
"                    local first_chr = string.sub(realVarValue, 1, 1);\n"
"                    local end_chr = string.sub(realVarValue, -1, -1);\n"
"                    if first_chr == end_chr then\n"
"                        if first_chr == \"'\" or first_chr == '\"' then\n"
"                            realVarValue = string.sub(realVarValue, 2, -2);\n"
"                            displayVarValue  = realVarValue;\n"
"                        end\n"
"                    end\n"
"                end\n"
"                if getVarRet[1].type == 'boolean' then\n"
"                    if getVarRet[1].value == \"true\" then\n"
"                        realVarValue = true;\n"
"                    else\n"
"                        realVarValue = false;\n"
"                    end\n"
"                end\n"
"                if getVarRet[1].type == 'nil' then realVarValue = nil end\n"
"            end\n"
"        else\n"
"            realVarValue = getVarRet[1].value;\n"
"        end\n"
"\n"
"        local setVarRet;\n"
"        if type(assigndVar) ~= table  then\n"
"            setVarRet = this.setVariableValue( varName, curStackId, realVarValue, setLimit );\n"
"        else\n"
"            assigndVar[varName] = realVarValue;\n"
"            setVarRet = true;\n"
"        end\n"
"\n"
"        if getVarRet[1].type == \"string\" then\n"
"            displayVarValue = '\"' .. displayVarValue .. '\"';\n"
"        end\n"
"\n"
"        if setVarRet ~= false and setVarRet ~= nil then\n"
"            local retTip = \"变量 \".. varName ..\" 赋值成功\";\n"
"            info = { success = \"true\", name = getVarRet[1].name , type = getVarRet[1].type , value = displayVarValue, variablesReference = tostring(getVarRet[1].variablesReference), tip = retTip};\n"
"        else\n"
"            info = { success = \"false\", type = type(realVarValue), value = displayVarValue, tip = \"找不到要设置的变量\"};\n"
"        end\n"
"\n"
"    else\n"
"        info = { success = \"false\", type = nil, value = nil, tip = \"输入的值无意义\"};\n"
"    end\n"
"    return info\n"
"end\n"
"\n"
"--接收消息\n"
"--这里维护一个接收消息队列，因为Lua端未做隔断符保护，变量赋值时请注意其中不要包含隔断符 |*|\n"
"-- @timeoutSec 超时时间\n"
"-- @return  boolean 成功/失败\n"
"function this.receiveMessage( timeoutSec )\n"
"    timeoutSec = timeoutSec or MAX_TIMEOUT_SEC;\n"
"    sock:settimeout(timeoutSec);\n"
"    --如果队列中还有消息，直接取出来交给dataProcess处理\n"
"    if #recvMsgQueue > 0 then\n"
"        local saved_cmd = recvMsgQueue[1];\n"
"        table.remove(recvMsgQueue, 1);\n"
"        this.dataProcess(saved_cmd);\n"
"        return true;\n"
"    end\n"
"\n"
"    if currentRunState == runState.DISCONNECT then\n"
"        this.disconnect();\n"
"        return false;\n"
"    end\n"
"\n"
"    if sock == nil then\n"
"        this.printToConsole(\"[debugger error]接收信息失败  |  reason: socket == nil\", 2);\n"
"        return;\n"
"    end\n"
"    local response, err = sock:receive();\n"
"    if response == nil then\n"
"        if err == \"closed\" then\n"
"            this.printToConsole(\"[debugger error]接收信息失败  |  reason:\"..err, 2);\n"
"            this.disconnect();\n"
"        end\n"
"        return false;\n"
"    else\n"
"\n"
"        --判断是否是一条消息，分拆\n"
"        local proc_response = string.sub(response, 1, -1 * (TCPSplitChar:len() + 1 ));\n"
"        local match_res = string.find(proc_response, TCPSplitChar, 1, true);\n"
"        if match_res == nil then\n"
"            --单条\n"
"            this.dataProcess(proc_response);\n"
"        else\n"
"            --有粘包\n"
"            repeat\n"
"                --待处理命令\n"
"                local str1 = string.sub(proc_response, 1, match_res - 1);\n"
"                table.insert(recvMsgQueue, str1);\n"
"                --剩余匹配\n"
"                local str2 = string.sub(proc_response, match_res + TCPSplitChar:len() , -1);\n"
"                match_res = string.find(str2, TCPSplitChar, 1, true);\n"
"            until not match_res\n"
"            this.receiveMessage();\n"
"        end\n"
"        return true;\n"
"    end\n"
"end\n"
"\n"
"--这里不用循环，在外面处理完消息会在调用回来\n"
"-- @timeoutSec 等待时间s\n"
"-- @entryFlag 入口标记，用来标识是从哪里调入的\n"
"function this.debugger_wait_msg(timeoutSec)\n"
"    timeoutSec = timeoutSec or MAX_TIMEOUT_SEC;\n"
"\n"
"    if currentRunState == runState.WAIT_CMD then\n"
"        local ret = this.receiveMessage(timeoutSec);\n"
"        return ret;\n"
"    end\n"
"\n"
"    if currentRunState == runState.STEPOVER or\n"
"    currentRunState == runState.STEPIN or\n"
"    currentRunState == runState.STEPOUT or\n"
"    currentRunState == runState.RUN then\n"
"        this.receiveMessage(0);\n"
"        return\n"
"    end\n"
"\n"
"    if currentRunState == runState.STEPOVER_STOP or\n"
"    currentRunState == runState.STEPIN_STOP or\n"
"    currentRunState == runState.STEPOUT_STOP or\n"
"    currentRunState == runState.HIT_BREAKPOINT or\n"
"    currentRunState == runState.STOP_ON_ENTRY\n"
"    then\n"
"        this.sendLuaMemory();\n"
"        this.receiveMessage(MAX_TIMEOUT_SEC);\n"
"        return\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 调试器核心方法\n"
"-----------------------------------------------------------------------------\n"
"\n"
"------------------------堆栈管理-------------------------\n"
"\n"
"\n"
"--getStackTable需要建立stackTable，保存每层的lua函数实例(用来取upvalue)，保存函数展示层级和ly的关系(便于根据前端传来的stackId查局部变量)\n"
"-- @level 要获取的层级\n"
"function this.getStackTable( level )\n"
"    local functionLevel = 0\n"
"    if hookLib ~= nil then\n"
"        functionLevel = level or HOOK_LEVEL;\n"
"    else\n"
"        functionLevel = level or this.getSpecificFunctionStackLevel(lastRunFunction.func);\n"
"    end\n"
"    local stackTab = {};\n"
"    local userFuncSteakLevel = 0; --用户函数的steaklevel\n"
"    repeat\n"
"        local info = debug.getinfo(functionLevel, \"SlLnf\")\n"
"        if info == nil then\n"
"            break;\n"
"        end\n"
"        if info.source == \"=[C]\" then\n"
"            break;\n"
"        end\n"
"\n"
"        local ss = {};\n"
"        ss.file = this.getPath(info);\n"
"        ss.name = \"文件名\"; --这里要做截取\n"
"        ss.line = tostring(info.currentline);\n"
"        --使用hookLib时，堆栈有偏移量，这里统一调用栈顶编号2\n"
"        local ssindex = functionLevel - 3;\n"
"        if hookLib ~= nil then\n"
"            ssindex = ssindex + 2;\n"
"        end\n"
"        ss.index = tostring(ssindex);\n"
"        table.insert(stackTab,ss);\n"
"        --把数据存入currentCallStack\n"
"        local callStackInfo = {};\n"
"        callStackInfo.name = ss.file;\n"
"        callStackInfo.line = ss.line;\n"
"        callStackInfo.func = info.func;     --保存的function\n"
"        callStackInfo.realLy = functionLevel;              --真实堆栈层functionLevel(仅debug时用)\n"
"        table.insert(currentCallStack, callStackInfo);\n"
"\n"
"        --level赋值\n"
"        if userFuncSteakLevel == 0 then\n"
"            userFuncSteakLevel = functionLevel;\n"
"        end\n"
"        functionLevel = functionLevel + 1;\n"
"    until info == nil\n"
"    return stackTab, userFuncSteakLevel;\n"
"end\n"
"\n"
"--这个方法是根据工程中的cwd和luaFileExtension修改\n"
"-- @info getInfo获取的包含调用信息table\n"
"function this.getPath( info )\n"
"    local filePath = info;\n"
"    if type(info) == \"table\" then\n"
"        filePath = info.source;\n"
"    end\n"
"    --尝试从Cache中获取路径\n"
"    local cachePath = this.getPathFromCache(filePath);\n"
"    if cachePath~= nil and type(cachePath) == \"string\" then\n"
"        return cachePath;\n"
"    end\n"
"\n"
"    local originalPath = filePath;\n"
"    --如果路径头部有@,去除\n"
"    if filePath:sub(1,1) == '@' then\n"
"        filePath = filePath:sub(2);\n"
"    end\n"
"\n"
"    --后缀处理\n"
"    if luaFileExtension ~= \"\" then\n"
"        --判断后缀中是否包含%1等魔法字符.用于从lua虚拟机获取到的路径含.的情况\n"
"        if string.find(luaFileExtension, \"%%%d\") then\n"
"            filePath = string.gsub(filePath, \"%.%w+$\", luaFileExtension);\n"
"        else\n"
"            filePath = string.gsub(filePath, \"%.%w+$\", \"\");\n"
"            filePath = filePath .. \".\" .. luaFileExtension;\n"
"        end\n"
"    end\n"
"\n"
"    --拼路径\n"
"    local retPath = filePath;\n"
"    --若在Mac下以/开头，或者在Win下以*:开头，说明是绝对路径，不需要再拼。\n"
"    if filePath:sub(1,1) == [[/]] or filePath:sub(1,2):match(\"^%a:\") then\n"
"        isAbsolutePath = true;\n"
"    else\n"
"        isAbsolutePath = false;\n"
"        if cwd ~= \"\" then\n"
"            --查看filePath中是否包含cwd\n"
"            local matchRes = string.find(filePath, cwd, 1, true);\n"
"            if matchRes == nil then\n"
"                retPath = cwd..\"/\"..filePath;\n"
"            end\n"
"        end\n"
"    end\n"
"    retPath = this.genUnifiedPath(retPath);\n"
"    --放入Cache中缓存\n"
"    this.setPathToCache(originalPath, retPath);\n"
"    return retPath;\n"
"end\n"
"\n"
"--获取当前函数的堆栈层级\n"
"--原理是向上查找，遇到DebuggerFileName就调过。但是可能存在代码段和C导致不确定性。目前使用getSpecificFunctionStackLevel代替。\n"
"function this.getCurrentFunctionStackLevel()\n"
"    -- print(debug.traceback(\"===getCurrentFunctionStackLevel Stack trace===\"))\n"
"    local funclayer = 2;\n"
"    repeat\n"
"        local info = debug.getinfo(funclayer, \"S\"); --通过name来判断\n"
"        if info ~= nil then\n"
"            local matchRes = ((info.source == DebuggerFileName) or (info.source == DebuggerToolsName));\n"
"            if matchRes == false then\n"
"                return (funclayer - 1);\n"
"            end\n"
"        end\n"
"        funclayer = funclayer + 1;\n"
"    until not info\n"
"    return 0;\n"
"end\n"
"\n"
"--获取指定函数的堆栈层级\n"
"--通常用来获取最后一个用户函数的层级，用法是从currentCallStack取用户点击的栈，再使用本函数取对应层级。\n"
"-- @func 被获取层级的function\n"
"function this.getSpecificFunctionStackLevel( func )\n"
"    local funclayer = 2;\n"
"    repeat\n"
"        local info = debug.getinfo(funclayer, \"f\"); --通过name来判断\n"
"        if info ~= nil then\n"
"            if info.func == func then\n"
"                return (funclayer - 1);\n"
"            end\n"
"        end\n"
"        funclayer = funclayer + 1;\n"
"    until not info\n"
"    return 0;\n"
"end\n"
"\n"
"--检查当前堆栈是否是Lua\n"
"-- @checkLayer 指定的栈层\n"
"function this.checkCurrentLayerisLua( checkLayer )\n"
"    local info = debug.getinfo(checkLayer, \"S\");\n"
"    if info == nil then\n"
"        return nil;\n"
"    end\n"
"    info.source = this.genUnifiedPath(info.source);\n"
"    if info ~= nil then\n"
"        for k,v in pairs(info) do\n"
"            if k == \"what\" then\n"
"                if v == \"C\" then\n"
"                    return false;\n"
"                else\n"
"                    return true;\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"    return nil;\n"
"end\n"
"\n"
"------------------------断点处理-------------------------\n"
"-- 参数info是当前堆栈信息\n"
"-- @info getInfo获取的当前调用信息\n"
"function this.isHitBreakpoint( info )\n"
"    local curPath = info.source;\n"
"    local curLine = tostring(info.currentline);\n"
"    if breaks[curPath] ~= nil then\n"
"        for k,v in ipairs(breaks[curPath]) do\n"
"            if tostring(v[\"line\"]) == tostring(curLine) then\n"
"                -- type是TS中的枚举类型，其定义在BreakPoint.tx文件中\n"
"                --[[\n"
"                    enum BreakpointType {\n"
"                        conditionBreakpoint = 0,\n"
"                        logPoint,\n"
"                        lineBreakpoint\n"
"                    }\n"
"                ]]\n"
"\n"
"                if v[\"type\"] == \"0\" then\n"
"                    -- condition breakpoint\n"
"                    -- 注意此处不要使用尾调用，否则会影响调用栈，导致Lua5.3和Lua5.1中调用栈层级不同\n"
"                    local conditionRet = this.IsMeetCondition(v[\"condition\"]);\n"
"                    return conditionRet;\n"
"                elseif v[\"type\"] == \"1\" then\n"
"                    -- log point\n"
"                    this.printToVSCode(\"[log point output]: \" .. v[\"logMessage\"], 1);\n"
"                else\n"
"                    -- line breakpoint\n"
"                    return true;\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"    return false;\n"
"end\n"
"\n"
"-- 条件断点处理函数\n"
"-- 返回true表示条件成立\n"
"-- @conditionExp 条件表达式\n"
"function this.IsMeetCondition(conditionExp)\n"
"    -- 判断条件之前更新堆栈信息\n"
"    currentCallStack = {};\n"
"    variableRefTab = {};\n"
"    variableRefIdx = 1;\n"
"    this.getStackTable();\n"
"    this.curStackId = 2; --在用户空间最上层执行\n"
"\n"
"    local conditionExpTable = {[\"varName\"] = conditionExp}\n"
"    local retTable = this.processWatchedExp(conditionExpTable)\n"
"\n"
"    local isMeetCondition = false;\n"
"    local function HandleResult()\n"
"        if retTable[1][\"isSuccess\"] == \"true\" then\n"
"            if retTable[1][\"value\"] == \"nil\" or (retTable[1][\"value\"] == \"false\" and retTable[1][\"type\"] == \"boolean\") then\n"
"                isMeetCondition = false;\n"
"            else\n"
"                isMeetCondition = true;\n"
"            end\n"
"        else\n"
"            isMeetCondition = false;\n"
"        end\n"
"    end\n"
"\n"
"    xpcall(HandleResult, function() isMeetCondition = false; end)\n"
"    return isMeetCondition;\n"
"end\n"
"\n"
"--加入断点函数\n"
"function this.BP()\n"
"    this.printToConsole(\"BP()\");\n"
"    if hookLib == nil then\n"
"        if currentHookState == hookState.DISCONNECT_HOOK then\n"
"            this.printToConsole(\"BP() but NO HOOK\");\n"
"            return;\n"
"        end\n"
"\n"
"        local co, isMain = coroutine.running();\n"
"        if _VERSION == \"Lua 5.1\" then\n"
"            if co == nil then\n"
"                isMain = true;\n"
"            else\n"
"                isMain = false;\n"
"            end\n"
"        end\n"
"\n"
"        if isMain == true then\n"
"            this.printToConsole(\"BP() in main\");\n"
"        else\n"
"            this.printToConsole(\"BP() in coroutine\");\n"
"            debug.sethook(co, this.debug_hook, \"lrc\");\n"
"        end\n"
"        hitBP = true;\n"
"    else\n"
"        if hookLib.get_libhook_state() == hookState.DISCONNECT_HOOK then\n"
"            this.printToConsole(\"BP() but NO C HOOK\");\n"
"            return;\n"
"        end\n"
"\n"
"        --clib, set hitBP\n"
"        hookLib.sync_bp_hit(1);\n"
"    end\n"
"    this.changeHookState(hookState.ALL_HOOK);\n"
"    return true;\n"
"end\n"
"\n"
"-- 检查当前文件中是否有断点\n"
"-- 如果填写参数fileName  返回fileName中有无断点， 全局有无断点\n"
"-- fileName为空，返回全局是否有断点\n"
"function this.checkHasBreakpoint(fileName)\n"
"    local hasBk = true;\n"
"    --有无全局断点\n"
"    if next(breaks) == nil then\n"
"        hasBk = false;\n"
"    else\n"
"        hasBk = true;\n"
"    end\n"
"    --当前文件中是否有断点\n"
"    if fileName ~= nil then\n"
"        return breaks[fileName] ~= nil, hasBk;\n"
"    else\n"
"        return hasBk;\n"
"    end\n"
"end\n"
"\n"
"function this.checkfuncHasBreakpoint(sLine, eLine, fileName)\n"
"    if breaks[fileName] == nil then\n"
"        return false;\n"
"    end\n"
"    sLine = tonumber(sLine);\n"
"    eLine = tonumber(eLine);\n"
"\n"
"    --起始行号>结束行号，或者sLine = eLine = 0\n"
"    if sLine >= eLine then\n"
"        return true;\n"
"    end\n"
"\n"
"    if #breaks[fileName] <= 0 then\n"
"        return false;\n"
"    else\n"
"        for k,v in ipairs(breaks[fileName]) do\n"
"            if tonumber(v.line) > sLine and tonumber(v.line) <= eLine then\n"
"                return true;\n"
"            end\n"
"        end\n"
"    end\n"
"    return false;\n"
"end\n"
"------------------------HOOK模块-------------------------\n"
"-- 钩子函数\n"
"-- @event 执行状态(call,return,line)\n"
"-- @line    行号\n"
"function this.debug_hook(event, line)\n"
"    if this.reConnect() == 1 then return; end\n"
"\n"
"    if logLevel == 0 then\n"
"        local logTable = {\"-----enter debug_hook-----\\n\", \"event:\", event, \"  line:\", tostring(line), \" currentHookState:\",currentHookState,\" currentRunState:\", currentRunState};\n"
"        local logString = table.concat(logTable);\n"
"        this.printToVSCode(logString);\n"
"    end\n"
"\n"
"    --litehook 仅非阻塞接收断点\n"
"    if currentHookState ==  hookState.LITE_HOOK then\n"
"        local ti = os.time();\n"
"        if ti - receiveMsgTimer > 1 then\n"
"            this.debugger_wait_msg(0);\n"
"            receiveMsgTimer = ti;\n"
"        end\n"
"        return;\n"
"    end\n"
"\n"
"    --运行中\n"
"    local info;\n"
"    local co, isMain = coroutine.running();\n"
"    if _VERSION == \"Lua 5.1\" then\n"
"        if co == nil then\n"
"            isMain = true;\n"
"        else\n"
"            isMain = false;\n"
"        end\n"
"    end\n"
"    isInMainThread = isMain;\n"
"    if isMain == true then\n"
"        info = debug.getinfo(2, \"Slf\")\n"
"    else\n"
"        info = debug.getinfo(co, 2, \"Slf\")\n"
"    end\n"
"    info.event = event;\n"
"\n"
"    this.real_hook_process(info);\n"
"end\n"
"\n"
"function this.real_hook_process(info)\n"
"    local jumpFlag = false;\n"
"    local event = info.event;\n"
"\n"
"    --如果当前行在Debugger中，不做处理\n"
"    local matchRes = ((info.source == DebuggerFileName) or (info.source == DebuggerToolsName));\n"
"    if matchRes == true and debugMode == false then\n"
"        return;\n"
"    end\n"
"\n"
"    --即使MID hook在C中, 或者是Run或者单步时也接收消息\n"
"    if currentRunState == runState.RUN or\n"
"    currentRunState == runState.STEPOVER or\n"
"    currentRunState == runState.STEPIN or\n"
"    currentRunState == runState.STEPOUT then\n"
"        local ti = os.time();\n"
"        if ti - receiveMsgTimer > 1 then\n"
"            this.debugger_wait_msg(0);\n"
"            receiveMsgTimer = ti;\n"
"        end\n"
"    end\n"
"\n"
"    --不处理C函数\n"
"    if info.source == \"=[C]\" then\n"
"        this.printToVSCode(\"current method is C\");\n"
"        return;\n"
"    end\n"
"\n"
"    --不处理 slua \"temp buffer\"\n"
"    if info.source == \"temp buffer\" then\n"
"        this.printToVSCode(\"current method is in temp buffer\");\n"
"        return;\n"
"    end\n"
"\n"
"    --不处理 xlua \"chunk\"\n"
"    if info.source == \"chunk\" then\n"
"        this.printToVSCode(\"current method is in chunk\");\n"
"        return;\n"
"    end\n"
"\n"
"    --lua 代码段的处理，目前暂不调试代码段。\n"
"    if info.short_src:match(\"%[string \\\"\")  then\n"
"            --当shortSrc中出现[string时]。要检查一下source, 区别是路径还是代码段. 方法是看路径中有没有\\t \\n ;\n"
"            if info.source:match(\"[\\n;=]\") then\n"
"                --是代码段，调过\n"
"                this.printToVSCode(\"hook jump Code String!\");\n"
"                jumpFlag = true;\n"
"            end\n"
"    end\n"
"\n"
"    --标准路径处理\n"
"    if jumpFlag == false then\n"
"        info.source = this.getPath(info);\n"
"    end\n"
"    --本次执行的函数和上次执行的函数作对比，防止在一行停留两次\n"
"    if lastRunFunction[\"currentline\"] == info[\"currentline\"] and lastRunFunction[\"source\"] == info[\"source\"] and lastRunFunction[\"func\"] == info[\"func\"] and lastRunFunction[\"event\"] == event then\n"
"        this.printToVSCode(\"run twice\");\n"
"    end\n"
"    --记录最后一次调用信息\n"
"    if jumpFlag == false then\n"
"        lastRunFunction = info;\n"
"        lastRunFunction[\"event\"] = event;\n"
"        lastRunFilePath = info.source;\n"
"    end\n"
"    --输出函数信息到前台\n"
"    if logLevel == 0 and jumpFlag == false then\n"
"        local logTable = {\"[lua hook] event:\", tostring(event), \" currentRunState:\",tostring(currentRunState),\" currentHookState:\",tostring(currentHookState),\" jumpFlag:\", tostring(jumpFlag)};\n"
"        for k,v in pairs(info) do\n"
"            table.insert(logTable, tostring(k));\n"
"            table.insert(logTable, \":\");\n"
"            table.insert(logTable, tostring(v));\n"
"            table.insert(logTable, \" \");\n"
"        end\n"
"        local logString = table.concat(logTable);\n"
"        this.printToVSCode(logString);\n"
"    end\n"
"\n"
"    --仅在line时做断点判断。进了断点之后不再进入本次STEP类型的判断，用Aflag做标记\n"
"    local isHit = false;\n"
"    if tostring(event) == \"line\" and jumpFlag == false then\n"
"        if currentRunState == runState.RUN or currentRunState == runState.STEPOVER or currentRunState == runState.STEPIN or currentRunState == runState.STEPOUT then\n"
"            --断点判断\n"
"            isHit = this.isHitBreakpoint(info) or hitBP;\n"
"            if isHit == true then\n"
"                this.printToVSCode(\" + HitBreakpoint true\");\n"
"                hitBP = false; --hitBP是断点硬性命中标记\n"
"                --计数器清0\n"
"                stepOverCounter = 0;\n"
"                stepOutCounter = 0;\n"
"                this.changeRunState(runState.HIT_BREAKPOINT);\n"
"                --发消息并等待\n"
"                this.SendMsgWithStack(\"stopOnBreakpoint\");\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    if  isHit == true then\n"
"        return;\n"
"    end\n"
"\n"
"    if currentRunState == runState.STEPOVER then\n"
"        -- line stepOverCounter!= 0 不作操作\n"
"        -- line stepOverCounter == 0 停止\n"
"        if event == \"line\" and stepOverCounter <= 0 and jumpFlag == false then\n"
"            stepOverCounter = 0;\n"
"            this.changeRunState(runState.STEPOVER_STOP)\n"
"            this.SendMsgWithStack(\"stopOnStep\");\n"
"        elseif event == \"return\" or event == \"tail return\" then\n"
"            --5.1中是tail return\n"
"            if stepOverCounter ~= 0 then\n"
"                stepOverCounter = stepOverCounter - 1;\n"
"            end\n"
"        elseif event == \"call\" then\n"
"            stepOverCounter = stepOverCounter + 1;\n"
"        end\n"
"    elseif currentRunState == runState.STOP_ON_ENTRY then\n"
"        --在Lua入口点处直接停住\n"
"        if event == \"line\" and jumpFlag == false then\n"
"            --初始化内存分析的变量\n"
"            -- MemProfiler.getSystemVar();\n"
"            --这里要判断一下是Lua的入口点，否则停到\n"
"            this.SendMsgWithStack(\"stopOnEntry\");\n"
"        end\n"
"    elseif currentRunState == runState.STEPIN then\n"
"        if event == \"line\" and jumpFlag == false then\n"
"            this.changeRunState(runState.STEPIN_STOP)\n"
"            this.SendMsgWithStack(\"stopOnStepIn\");\n"
"        end\n"
"    elseif currentRunState == runState.STEPOUT then\n"
"        --line 不做操作\n"
"        --in 计数器+1\n"
"        --out 计数器-1\n"
"        if jumpFlag == false then\n"
"            if stepOutCounter <= -1 then\n"
"                stepOutCounter = 0;\n"
"                this.changeRunState(runState.STEPOUT_STOP)\n"
"                this.SendMsgWithStack(\"stopOnStepOut\");\n"
"            end\n"
"        end\n"
"\n"
"        if event == \"return\" or event == \"tail return\" then\n"
"            stepOutCounter = stepOutCounter - 1;\n"
"        elseif event == \"call\" then\n"
"            stepOutCounter = stepOutCounter + 1;\n"
"        end\n"
"    end\n"
"\n"
"    --在RUN时检查并改变状态\n"
"    if hookLib == nil then\n"
"        if currentRunState == runState.RUN and jumpFlag == false and currentHookState ~= hookState.DISCONNECT_HOOK then\n"
"            local fileBP, G_BP =this.checkHasBreakpoint(lastRunFilePath);\n"
"            if fileBP == false then\n"
"                --文件无断点\n"
"                if G_BP == true then\n"
"                    this.changeHookState(hookState.MID_HOOK);\n"
"                else\n"
"                    this.changeHookState(hookState.LITE_HOOK);\n"
"                end\n"
"            else\n"
"                --文件有断点\n"
"                --判断函数内是否有断点\n"
"                local funHasBP = this.checkfuncHasBreakpoint(lastRunFunction.linedefined, lastRunFunction.lastlinedefined, lastRunFilePath);\n"
"                if  funHasBP then\n"
"                    --函数定义范围内\n"
"                    this.changeHookState(hookState.ALL_HOOK);\n"
"                else\n"
"                    this.changeHookState(hookState.MID_HOOK);\n"
"                end\n"
"            end\n"
"\n"
"            --MID_HOOK状态下，return需要在下一次hook检查文件（return时，还是当前文件，检查文件时状态无法转换）\n"
"            if  (event == \"return\" or event == \"tail return\") and currentHookState == hookState.MID_HOOK then\n"
"                this.changeHookState(hookState.ALL_HOOK);\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- 向Vscode发送标准通知消息，cmdStr是消息类型\n"
"-- @cmdStr  命令字\n"
"function this.SendMsgWithStack(cmdStr)\n"
"    local msgTab = this.getMsgTable(cmdStr);\n"
"    local userFuncLevel = 0;\n"
"    msgTab[\"stack\"] , userFuncLevel= this.getStackTable();\n"
"    if userFuncLevel ~= 0 then\n"
"        lastRunFunction[\"func\"] = debug.getinfo( (userFuncLevel - 1) , 'f').func;\n"
"    end\n"
"    this.sendMsg(msgTab);\n"
"    this.debugger_wait_msg();\n"
"end\n"
"\n"
"-- hook状态改变\n"
"-- @s 目标状态\n"
"function this.changeHookState( s )\n"
"    if hookLib == nil and currentHookState == s then\n"
"        return;\n"
"    end\n"
"\n"
"    this.printToConsole(\"change hook state :\"..s)\n"
"    if s ~= hookState.DISCONNECT_HOOK then\n"
"        this.printToVSCode(\"change hook state : \"..s)\n"
"    end\n"
"\n"
"    currentHookState = s;\n"
"    if s == hookState.DISCONNECT_HOOK then\n"
"        --为了实现通用attach模式，require即开始hook，利用r作为时机发起连接\n"
"        if openAttachMode == true then\n"
"            if hookLib then hookLib.lua_set_hookstate(hookState.DISCONNECT_HOOK); else debug.sethook(this.debug_hook, \"r\", 1000000); end\n"
"        else\n"
"            if hookLib then hookLib.endHook(); else debug.sethook(); end\n"
"        end\n"
"    elseif s == hookState.LITE_HOOK then\n"
"        if hookLib then hookLib.lua_set_hookstate(hookState.LITE_HOOK); else debug.sethook(this.debug_hook, \"r\"); end\n"
"    elseif s == hookState.MID_HOOK then\n"
"        if hookLib then hookLib.lua_set_hookstate(hookState.MID_HOOK); else debug.sethook(this.debug_hook, \"rc\"); end\n"
"    elseif s == hookState.ALL_HOOK then\n"
"        if hookLib then hookLib.lua_set_hookstate(hookState.ALL_HOOK); else debug.sethook(this.debug_hook, \"lrc\");end\n"
"    end\n"
"    --coroutine\n"
"    if hookLib == nil then\n"
"        this.changeCoroutineHookState();\n"
"    end\n"
"end\n"
"\n"
"-- 运行状态机，状态变更\n"
"-- @s 目标状态\n"
"-- @isFromHooklib 1:从libc库中发来的状态改变 | 0:lua发来的状态改变\n"
"function this.changeRunState(s , isFromHooklib)\n"
"    local msgFrom;\n"
"    if isFromHooklib == 1 then\n"
"        msgFrom = \"libc\";\n"
"    else\n"
"        msgFrom = \"lua\";\n"
"    end\n"
"\n"
"    --WAIT_CMD状态会等待接收消息，以下两个状态下不能发消息\n"
"    this.printToConsole(\"changeRunState :\"..s.. \" | from:\"..msgFrom);\n"
"    if s ~= runState.DISCONNECT and s ~= runState.WAIT_CMD then\n"
"        this.printToVSCode(\"changeRunState :\"..s..\" | from:\"..msgFrom);\n"
"    end\n"
"\n"
"    if hookLib ~= nil and isFromHooklib ~= 1 then\n"
"        hookLib.lua_set_runstate(s);\n"
"    end\n"
"    currentRunState = s;\n"
"    --状态切换时，清除记录栈信息的状态\n"
"    currentCallStack = {};\n"
"    variableRefTab = {};\n"
"    variableRefIdx = 1;\n"
"end\n"
"\n"
"-- 修改协程状态\n"
"-- @s hook标志位\n"
"function this.changeCoroutineHookState(s)\n"
"    s = s or currentHookState;\n"
"    this.printToConsole(\"change [Coroutine] HookState: \"..tostring(s));\n"
"    for k ,co in pairs(coroutinePool) do\n"
"        if coroutine.status(co) == \"dead\" then\n"
"            table.remove(coroutinePool, k)\n"
"        else\n"
"            if s == hookState.DISCONNECT_HOOK then\n"
"                if openAttachMode == true then\n"
"                    debug.sethook(co, this.debug_hook, \"r\", 1000000);\n"
"                else\n"
"                    debug.sethook(co, this.debug_hook, \"\");\n"
"                end\n"
"            elseif s == hookState.LITE_HOOK then debug.sethook(co , this.debug_hook, \"r\");\n"
"            elseif s == hookState.MID_HOOK then debug.sethook(co , this.debug_hook, \"rc\");\n"
"            elseif s == hookState.ALL_HOOK then debug.sethook(co , this.debug_hook, \"lrc\");\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"-------------------------变量处理相关-----------------------------\n"
"\n"
"--清空REPL的evn环境\n"
"function this.clearEnv()\n"
"    if this.getTableMemberNum(env) > 0 then\n"
"        --清空env table\n"
"        env = setmetatable({}, getmetatable(env));\n"
"    end\n"
"end\n"
"\n"
"--返回REPL的evn环境\n"
"function this.showEnv()\n"
"    return env;\n"
"end\n"
"\n"
"-- 用户观察table的查找函数。用tableVarName作为key去查逐层级查找realVar是否匹配\n"
"-- @tableVarName 是用户观察的变量名，已经按层级被解析成table。比如用户输出a.b.c，tableVarName是 a = { b = { c } }\n"
"-- @realVar 是待查询 table\n"
"-- @return  返回查到的table。没查到返回nil\n"
"function this.findTableVar( tableVarName,  realVar)\n"
"    if type(tableVarName) ~= \"table\" or type(realVar) ~= \"table\" then\n"
"        return nil;\n"
"    end\n"
"\n"
"    local layer = 2;\n"
"    local curVar = realVar;\n"
"    local jumpOutFlag = false;\n"
"    repeat\n"
"        if tableVarName[layer] ~= nil then\n"
"            --这里优先展示数字key，比如a{\"1\" = \"aa\", [1] = \"bb\"} 会展示[1]的值\n"
"            local tmpCurVar = nil;\n"
"            xpcall(function() tmpCurVar = curVar[tonumber(tableVarName[layer])]; end , function() tmpCurVar = nil end );\n"
"            if tmpCurVar == nil then\n"
"                xpcall(function() curVar = curVar[tostring(tableVarName[layer])]; end , function() curVar = nil end );\n"
"            else\n"
"                curVar = tmpCurVar;\n"
"            end\n"
"            layer = layer + 1;\n"
"            if curVar == nil then\n"
"                return nil;\n"
"            end\n"
"        else\n"
"            --找到\n"
"            jumpOutFlag = true;\n"
"        end\n"
"    until(jumpOutFlag == true)\n"
"    return curVar;\n"
"end\n"
"\n"
"-- 根据传入信息生成返回的变量信息\n"
"-- @variableName    变量名\n"
"-- @variableIns        变量实例\n"
"-- @return              包含变量信息的格式化table\n"
"function this.createWatchedVariableInfo(variableName, variableIns)\n"
"    local var = {};\n"
"    var.name = variableName;\n"
"    var.type = tostring(type(variableIns));\n"
"    xpcall(function() var.value = tostring(variableIns) end , function() var.value = tostring(type(variableIns)) .. \" [value can't trans to string]\" end );\n"
"    var.variablesReference = \"0\";  --这个地方必须用“0”， 以免variableRefTab[0]出错\n"
"\n"
"    if var.type == \"table\" or var.type == \"function\" then\n"
"        var.variablesReference = variableRefIdx;\n"
"        variableRefTab[variableRefIdx] = variableIns;\n"
"        variableRefIdx = variableRefIdx + 1;\n"
"        if var.type == \"table\" then\n"
"            local memberNum = this.getTableMemberNum(variableIns);\n"
"            var.value = memberNum ..\" Members \".. var.value;\n"
"        end\n"
"    elseif var.type == \"string\" then\n"
"        var.value = '\"' ..variableIns.. '\"';\n"
"    end\n"
"    return var;\n"
"end\n"
"\n"
"-- 设置 global 变量\n"
"-- @varName 被修改的变量名\n"
"-- @newValue 新的值\n"
"function this.setGlobal(varName, newValue)\n"
"    _G[varName] = newValue;\n"
"    this.printToVSCode(\"[setVariable success] 已设置  _G.\".. varName .. \" = \" .. tostring(newValue) );\n"
"    return true;\n"
"end\n"
"\n"
"-- 设置 upvalue 变量\n"
"-- @varName 被修改的变量名\n"
"-- @newValue 新的值\n"
"-- @stackId 变量所在stack栈层\n"
"-- @tableVarName 变量名拆分成的数组\n"
"function this.setUpvalue(varName, newValue, stackId, tableVarName)\n"
"    local ret = false;\n"
"    local upTable = this.getUpValueVariable(currentCallStack[stackId - 1 ].func, true);\n"
"    for i, realVar in ipairs(upTable) do\n"
"        if realVar.name == varName then\n"
"            if #tableVarName > 0 and type(realVar) == \"table\" then\n"
"                --处理a.b.c的table类型\n"
"                local findRes = this.findTableVar(tableVarName,  variableRefTab[realVar.variablesReference]);\n"
"                if findRes ~= nil then\n"
"                    --命中\n"
"                        local setVarRet = debug.setupvalue (currentCallStack[stackId - 1 ].func, i, newValue);\n"
"                        if setVarRet == varName then\n"
"                            this.printToConsole(\"[setVariable success1] 已设置 upvalue \".. varName .. \" = \" .. tostring(newValue) );\n"
"                            ret = true;\n"
"                        else\n"
"                            this.printToConsole(\"[setVariable error1] 未能设置 upvalue \".. varName .. \" = \" .. tostring(newValue)..\" , 返回结果: \".. tostring(setVarRet));\n"
"                        end\n"
"                        return ret;\n"
"                end\n"
"            else\n"
"                --命中\n"
"                local setVarRet = debug.setupvalue (currentCallStack[stackId - 1 ].func, i, newValue);\n"
"                if setVarRet == varName then\n"
"                    this.printToConsole(\"[setVariable success] 已设置 upvalue \".. varName .. \" = \" .. tostring(newValue) );\n"
"                    ret = true;\n"
"                else\n"
"                    this.printToConsole(\"[setVariable error] 未能设置 upvalue \".. varName .. \" = \" .. tostring(newValue)..\" , 返回结果: \".. tostring(setVarRet));\n"
"                end\n"
"                return ret;\n"
"            end\n"
"        end\n"
"    end\n"
"    return ret;\n"
"end\n"
"\n"
"-- 设置local 变量\n"
"-- @varName 被修改的变量名\n"
"-- @newValue 新的值\n"
"-- @tableVarName 变量名拆分成的数组\n"
"function this.setLocal( varName, newValue, tableVarName, stackId)\n"
"    local istackId = tonumber(stackId);\n"
"    local offset = (istackId and istackId - 2) or 0;\n"
"    local layerVarTab, ly = this.getVariable(nil , true, offset);\n"
"    local ret = false;\n"
"    for i, realVar in ipairs(layerVarTab) do\n"
"        if realVar.name == varName then\n"
"            if #tableVarName > 0 and type(realVar) == \"table\" then\n"
"                --处理a.b.c的table类型\n"
"                local findRes = this.findTableVar(tableVarName,  variableRefTab[realVar.variablesReference]);\n"
"                if findRes ~= nil then\n"
"                        --命中\n"
"                        local setVarRet = debug.setlocal(ly , layerVarTab[i].index, newValue);\n"
"                        if setVarRet == varName then\n"
"                            this.printToConsole(\"[setVariable success1] 已设置 local \".. varName .. \" = \" .. tostring(newValue) );\n"
"                            ret = true;\n"
"                        else\n"
"                            this.printToConsole(\"[setVariable error1] 未能设置 local \".. varName .. \" = \" .. tostring(newValue)..\" , 返回结果: \".. tostring(setVarRet));\n"
"                        end\n"
"                        return ret;\n"
"                end\n"
"            else\n"
"\n"
"                local setVarRet = debug.setlocal(ly , layerVarTab[i].index, newValue);\n"
"\n"
"                if setVarRet == varName then\n"
"                    this.printToConsole(\"[setVariable success] 已设置 local \".. varName .. \" = \" .. tostring(newValue) );\n"
"                    ret = true;\n"
"                else\n"
"                    this.printToConsole(\"[setVariable error] 未能设置 local \".. varName .. \" = \" .. tostring(newValue) ..\" , 返回结果: \".. tostring(setVarRet));\n"
"                end\n"
"                return ret;\n"
"            end\n"
"        end\n"
"    end\n"
"    return ret;\n"
"end\n"
"\n"
"\n"
"-- 设置变量的值\n"
"-- @varName 被修改的变量名\n"
"-- @curStackId 调用栈层级(仅在固定栈层查找)\n"
"-- @newValue 新的值\n"
"-- @limit 限制符， 10000表示仅在局部变量查找 ，20000 global, 30000 upvalue\n"
"function this.setVariableValue (varName, stackId, newValue , limit)\n"
"    this.printToConsole(\"setVariableValue | varName:\" .. tostring(varName) .. \" stackId:\".. tostring(stackId) ..\" newValue:\" .. tostring(newValue) ..\" limit:\"..tostring(limit) )\n"
"    if tostring(varName) == nil or tostring(varName) == \"\" then\n"
"        --赋值错误\n"
"        this.printToConsole(\"[setVariable Error] 被赋值的变量名为空\", 2 );\n"
"        this.printToVSCode(\"[setVariable Error] 被赋值的变量名为空\", 2 );\n"
"        return false;\n"
"    end\n"
"\n"
"    --支持a.b.c形式。切割varName\n"
"    local tableVarName = {};\n"
"    if varName:match('%.') then\n"
"        tableVarName = this.stringSplit(varName , '%.');\n"
"        if type(tableVarName) ~= \"table\" or #tableVarName < 1 then\n"
"            return false;\n"
"        end\n"
"        varName = tableVarName[1];\n"
"    end\n"
"\n"
"    if limit == \"local\" then\n"
"        local ret = this.setLocal( varName, newValue, tableVarName, stackId);\n"
"        return ret;\n"
"    elseif limit == \"upvalue\" then\n"
"        local ret = this.setUpvalue(varName, newValue, stackId, tableVarName);\n"
"        return ret\n"
"    elseif limit == \"global\" then\n"
"        local ret = this.setGlobal(varName, newValue);\n"
"        return ret;\n"
"    else\n"
"        local ret = this.setLocal( varName, newValue, tableVarName, stackId) or this.setUpvalue(varName, newValue, stackId, tableVarName) or this.setGlobal(varName, newValue);\n"
"        this.printToConsole(\"set Value res :\".. tostring(ret));\n"
"        return ret;\n"
"    end\n"
"end\n"
"\n"
"-- 按照local -> upvalue -> _G 顺序查找观察变量\n"
"-- @varName 用户输入的变量名\n"
"-- @stackId 调用栈层级(仅在固定栈层查找)\n"
"-- @isFormatVariable    是否把变量格式化为VSCode接收的形式\n"
"-- @return 查到返回信息，查不到返回nil\n"
"function this.getWatchedVariable( varName , stackId , isFormatVariable )\n"
"    this.printToConsole(\"getWatchedVariable | varName:\" .. tostring(varName) .. \" stackId:\".. tostring(stackId) ..\" isFormatVariable:\" .. tostring(isFormatVariable) )\n"
"    if tostring(varName) == nil or tostring(varName) == \"\" then\n"
"        return nil;\n"
"    end\n"
"\n"
"    if type(currentCallStack[stackId - 1]) ~= \"table\" or  type(currentCallStack[stackId - 1].func) ~= \"function\" then\n"
"        local str = \"getWatchedVariable currentCallStack \" .. stackId - 1 .. \" Error\\n\" .. this.printTable(currentCallStack, \"currentCallStack\");\n"
"        this.printToVSCode(str, 2);\n"
"        return nil;\n"
"    end\n"
"\n"
"    --orgname 记录原名字. 用来处理a.b.c的形式\n"
"    local orgname = varName;\n"
"    --支持a.b.c形式。切割varName\n"
"    local tableVarName = {};\n"
"    if varName:match('%.') then\n"
"        tableVarName = this.stringSplit(varName , '%.');\n"
"        if type(tableVarName) ~= \"table\" or #tableVarName < 1 then\n"
"            return nil;\n"
"        end\n"
"        varName = tableVarName[1];\n"
"    end\n"
"    --用来返回，带有查到变量的table\n"
"    local varTab = {};\n"
"    local ly = this.getSpecificFunctionStackLevel(currentCallStack[stackId - 1].func);\n"
"\n"
"    local layerVarTab = this.getVariable(ly, isFormatVariable);\n"
"    local upTable = this.getUpValueVariable(currentCallStack[stackId - 1 ].func, isFormatVariable);\n"
"    local travelTab = {};\n"
"    table.insert(travelTab, layerVarTab);\n"
"    table.insert(travelTab, upTable);\n"
"    for _, layerVarTab in ipairs(travelTab) do\n"
"        for i,realVar in ipairs(layerVarTab) do\n"
"            if realVar.name == varName then\n"
"                if #tableVarName > 0 and type(realVar) == \"table\" then\n"
"                    --处理a.b.c的table类型\n"
"                    local findRes = this.findTableVar(tableVarName,  variableRefTab[realVar.variablesReference]);\n"
"                    if findRes ~= nil then\n"
"                        --命中\n"
"                        if isFormatVariable then\n"
"                            local var = this.createWatchedVariableInfo( orgname , findRes );\n"
"                            table.insert(varTab, var);\n"
"                            return varTab;\n"
"                        else\n"
"                            return findRes.value;\n"
"                        end\n"
"                    end\n"
"                else\n"
"                    --命中\n"
"                    if isFormatVariable then\n"
"                        table.insert(varTab, realVar);\n"
"                        return varTab;\n"
"                    else\n"
"                        return realVar.value;\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    --在全局变量_G中查找\n"
"    if _G[varName] ~= nil then\n"
"        --命中\n"
"        if #tableVarName > 0 and type(_G[varName]) == \"table\" then\n"
"            local findRes = this.findTableVar(tableVarName,  _G[varName]);\n"
"            if findRes ~= nil then\n"
"                if isFormatVariable then\n"
"                    local var = this.createWatchedVariableInfo( orgname , findRes );\n"
"                    table.insert(varTab, var);\n"
"                    return varTab;\n"
"                else\n"
"                    return findRes;\n"
"                end\n"
"            end\n"
"        else\n"
"            if isFormatVariable then\n"
"                local var = this.createWatchedVariableInfo( varName , _G[varName] );\n"
"                table.insert(varTab, var);\n"
"                return varTab;\n"
"            else\n"
"                return _G[varName];\n"
"            end\n"
"        end\n"
"    end\n"
"    this.printToConsole(\"getWatchedVariable not find variable\");\n"
"    return nil;\n"
"end\n"
"\n"
"-- 查询引用变量\n"
"-- @refStr 变量记录id(variableRefTab索引)\n"
"-- @return 格式化的变量信息table\n"
"function this.getVariableRef( refStr )\n"
"    local varRef = tonumber(refStr);\n"
"    local varTab = {};\n"
"\n"
"    if tostring(type(variableRefTab[varRef])) == \"table\" then\n"
"        for n,v in pairs(variableRefTab[varRef]) do\n"
"            local var = {};\n"
"            var.name = tostring(n);\n"
"            var.type = tostring(type(v));\n"
"            xpcall(function() var.value = tostring(v) end , function() var.value = tostring(type(v)) .. \" [value can't trans to string]\" end );\n"
"            var.variablesReference = \"0\";\n"
"            if var.type == \"table\" or var.type == \"function\" then\n"
"                var.variablesReference = variableRefIdx;\n"
"                variableRefTab[variableRefIdx] = v;\n"
"                variableRefIdx = variableRefIdx + 1;\n"
"                if var.type == \"table\" then\n"
"                    local memberNum = this.getTableMemberNum(v);\n"
"                    var.value = memberNum ..\" Members \".. ( var.value or '' );\n"
"                end\n"
"            elseif var.type == \"string\" then\n"
"                var.value = '\"' ..v.. '\"';\n"
"            end\n"
"            table.insert(varTab, var);\n"
"        end\n"
"        --获取一下mtTable\n"
"        local mtTab = getmetatable(variableRefTab[varRef]);\n"
"        if mtTab ~= nil and type(mtTab) == \"table\" then\n"
"            local var = {};\n"
"            var.name = \"_Metatable_\";\n"
"            var.type = tostring(type(mtTab));\n"
"            xpcall(function() var.value = \"元表 \"..tostring(mtTab); end , function() var.value = \"元表 [value can't trans to string]\" end );\n"
"            var.variablesReference = variableRefIdx;\n"
"            variableRefTab[variableRefIdx] = mtTab;\n"
"            variableRefIdx = variableRefIdx + 1;\n"
"            table.insert(varTab, var);\n"
"        end\n"
"    elseif tostring(type(variableRefTab[varRef])) == \"function\" then\n"
"        --取upvalue\n"
"        varTab = this.getUpValueVariable(variableRefTab[varRef], true);\n"
"    elseif tostring(type(variableRefTab[varRef])) == \"userdata\" then\n"
"        --取mt table\n"
"        local udMtTable = getmetatable(variableRefTab[varRef]);\n"
"        if udMtTable ~= nil and type(udMtTable) == \"table\" then\n"
"            local var = {};\n"
"            var.name = \"_Metatable_\";\n"
"            var.type = tostring(type(udMtTable));\n"
"            xpcall(function() var.value = \"元表 \"..tostring(udMtTable); end , function() var.value = \"元表 [value can't trans to string]\" end );\n"
"            var.variablesReference = variableRefIdx;\n"
"            variableRefTab[variableRefIdx] = udMtTable;\n"
"            variableRefIdx = variableRefIdx + 1;\n"
"            table.insert(varTab, var);\n"
"        end\n"
"    end\n"
"    return varTab;\n"
"end\n"
"\n"
"-- 获取全局变量。方法和内存管理中获取全局变量的方法一样\n"
"-- @return 格式化的信息, 若未找到返回空table\n"
"function this.getGlobalVariable( ... )\n"
"    --成本比较高，这里只能遍历_G中的所有变量，并去除系统变量，再返回给客户端\n"
"    local varTab = {};\n"
"    for k,v in pairs(_G) do\n"
"        local var = {};\n"
"        var.name = tostring(k);\n"
"        var.type = tostring(type(v));\n"
"        xpcall(function() var.value = tostring(v) end , function() var.value =  tostring(type(v)) ..\" [value can't trans to string]\" end );\n"
"        var.variablesReference = \"0\";\n"
"        if var.type == \"table\" or var.type == \"function\" then\n"
"            var.variablesReference = variableRefIdx;\n"
"            variableRefTab[variableRefIdx] = v;\n"
"            variableRefIdx = variableRefIdx + 1;\n"
"            if var.type == \"table\" then\n"
"                local memberNum = this.getTableMemberNum(v);\n"
"                var.value = memberNum ..\" Members \".. ( var.value or '' );\n"
"            end\n"
"        elseif var.type == \"string\" then\n"
"            var.value = '\"' ..v.. '\"';\n"
"        end\n"
"        table.insert(varTab, var);\n"
"    end\n"
"    return varTab;\n"
"end\n"
"\n"
"-- 获取upValues\n"
"-- @isFormatVariable  true返回[值]  true返回[格式化的数据]\n"
"function this.getUpValueVariable( checkFunc , isFormatVariable)\n"
"    local isGetValue = true;\n"
"    if isFormatVariable == true then\n"
"        isGetValue = false;\n"
"    end\n"
"\n"
"    --通过Debug获取当前函数的Func\n"
"    checkFunc = checkFunc or lastRunFunction.func;\n"
"\n"
"    local varTab = {};\n"
"    if checkFunc == nil then\n"
"        return varTab;\n"
"    end\n"
"    local i = 1\n"
"    repeat\n"
"        local n, v = debug.getupvalue(checkFunc, i)\n"
"        if n then\n"
"\n"
"        local var = {};\n"
"        var.name = n;\n"
"        var.type = tostring(type(v));\n"
"        var.variablesReference = \"0\";\n"
"\n"
"        if isGetValue == false then\n"
"            xpcall(function() var.value = tostring(v) end , function() var.value = tostring(type(v)) .. \" [value can't trans to string]\" end );\n"
"            if var.type == \"table\" or var.type == \"function\" then\n"
"                var.variablesReference = variableRefIdx;\n"
"                variableRefTab[variableRefIdx] = v;\n"
"                variableRefIdx = variableRefIdx + 1;\n"
"                if var.type == \"table\" then\n"
"                    local memberNum = this.getTableMemberNum(v);\n"
"                    var.value = memberNum ..\" Members \".. ( var.value or '' );\n"
"                end\n"
"            elseif var.type == \"string\" then\n"
"                var.value = '\"' ..v.. '\"';\n"
"            end\n"
"        else\n"
"            var.value = v;\n"
"        end\n"
"\n"
"        table.insert(varTab, var);\n"
"        i = i + 1\n"
"        end\n"
"    until not n\n"
"    return varTab;\n"
"end\n"
"\n"
"-- 获取局部变量 checkLayer是要查询的层级，如果不设置则查询当前层级\n"
"-- @isFormatVariable 是否取值，true:取值的tostring\n"
"function this.getVariable( checkLayer, isFormatVariable , offset)\n"
"    local isGetValue = true;\n"
"    if isFormatVariable == true then\n"
"        isGetValue = false;\n"
"    end\n"
"\n"
"    local ly = 0;\n"
"    if checkLayer ~= nil and type(checkLayer) == \"number\" then ly = checkLayer + 1;\n"
"    else  ly = this.getSpecificFunctionStackLevel(lastRunFunction.func); end\n"
"\n"
"    if ly == 0 then\n"
"        this.printToVSCode(\"[error]获取层次失败！\", 2);\n"
"        return;\n"
"    end\n"
"    local varTab = {};\n"
"    local stacklayer = ly;\n"
"    local k = 1;\n"
"\n"
"    if type(offset) == 'number' then\n"
"        stacklayer = stacklayer + offset;\n"
"    end\n"
"\n"
"    repeat\n"
"        local n, v = debug.getlocal(stacklayer, k)\n"
"        if n == nil then\n"
"            break;\n"
"        end\n"
"\n"
"        --(*temporary)是系统变量，过滤掉。这里假设(*temporary)仅出现在最后\n"
"        if \"(*temporary)\" ~= tostring(n) then\n"
"            local var = {};\n"
"            var.name = n;\n"
"            var.type = tostring(type(v));\n"
"            var.variablesReference = \"0\";\n"
"            var.index = k;\n"
"\n"
"            if isGetValue == false then\n"
"                xpcall(function() var.value = tostring(v) end , function() var.value = tostring(type(v)) .. \" [value can't trans to string]\" end );\n"
"                if var.type == \"table\" or var.type == \"function\" then\n"
"                    var.variablesReference = variableRefIdx;\n"
"                    variableRefTab[variableRefIdx] = v;\n"
"                    variableRefIdx = variableRefIdx + 1;\n"
"                    if var.type == \"table\" then\n"
"                        local memberNum = this.getTableMemberNum(v);\n"
"                        var.value = memberNum ..\" Members \".. ( var.value or '' );\n"
"                    end\n"
"                elseif var.type == \"string\" then\n"
"                        var.value = '\"' ..v.. '\"';\n"
"                end\n"
"            else\n"
"                var.value = v;\n"
"            end\n"
"\n"
"            local sameIdx = this.checkSameNameVar(varTab, var);\n"
"            if sameIdx ~= 0 then\n"
"                varTab[sameIdx] = var;\n"
"            else\n"
"                table.insert(varTab, var);\n"
"            end\n"
"        end\n"
"        k = k + 1\n"
"    until n == nil\n"
"    return varTab, stacklayer - 1;\n"
"end\n"
"\n"
"--检查变量列表中的同名变量\n"
"function this.checkSameNameVar(varTab, var)\n"
"    for k , v in pairs(varTab) do\n"
"        if v.name == var.name then\n"
"            return k;\n"
"        end\n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"-- 执行表达式\n"
"function this.processExp(msgTable)\n"
"    local retString;\n"
"    local var = {};\n"
"    var.isSuccess = \"true\";\n"
"    if msgTable ~= nil then\n"
"        local expression = this.trim(tostring(msgTable.Expression));\n"
"        local isCmd = false;\n"
"        if isCmd == false then\n"
"            --兼容旧版p 命令\n"
"            if expression:find(\"p \", 1, true) == 1 then\n"
"                expression = expression:sub(3);\n"
"            end\n"
"\n"
"            local expressionWithReturn = \"return \" .. expression;\n"
"            local f = debugger_loadString(expressionWithReturn) or debugger_loadString(expression);\n"
"            --判断结果，如果表达式错误会返回nil\n"
"            if type(f) == \"function\" then\n"
"                if _VERSION == \"Lua 5.1\" then\n"
"                    setfenv(f , env);\n"
"                else\n"
"                    debug.setupvalue(f, 1, env);\n"
"                end\n"
"                --表达式要有错误处理\n"
"                xpcall(function() retString = f() end , function() retString = \"输入错误指令。\\n + 请检查指令是否正确\\n + 指令仅能在[暂停在断点时]输入, 请不要在程序持续运行时输入\"; var.isSuccess = false; end)\n"
"            else\n"
"                retString = \"指令执行错误。\\n + 请检查指令是否正确\\n + 可以直接输入表达式，执行函数或变量名，并观察执行结果\";\n"
"                var.isSuccess = false;\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    var.name = \"Exp\";\n"
"    var.type = tostring(type(retString));\n"
"    xpcall(function() var.value = tostring(retString) end , function(e) var.value = tostring(type(retString))  .. \" [value can't trans to string] \".. e; var.isSuccess = false; end);\n"
"    var.variablesReference = \"0\";\n"
"    if var.type == \"table\" or var.type == \"function\" then\n"
"        variableRefTab[variableRefIdx] = retString;\n"
"        var.variablesReference = variableRefIdx;\n"
"        variableRefIdx = variableRefIdx + 1;\n"
"        if var.type == \"table\" then\n"
"            local memberNum = this.getTableMemberNum(retString);\n"
"            var.value = memberNum ..\" Members \".. var.value;\n"
"        end\n"
"    elseif var.type == \"string\" then\n"
"        var.value = '\"' ..retString.. '\"';\n"
"    end\n"
"    --string执行完毕后清空evn环境\n"
"    this.clearEnv();\n"
"    local retTab = {}\n"
"    table.insert(retTab ,var);\n"
"    return retTab;\n"
"end\n"
"\n"
"--执行变量观察表达式\n"
"function this.processWatchedExp(msgTable)\n"
"    local retString;\n"
"    local expression = \"return \".. tostring(msgTable.varName)\n"
"    this.printToConsole(\"processWatchedExp | expression: \" .. expression);\n"
"    local f = debugger_loadString(expression);\n"
"    local var = {};\n"
"    var.isSuccess = \"true\";\n"
"    --判断结果，如果表达式错误会返回nil\n"
"    if type(f) == \"function\" then\n"
"        --表达式正确\n"
"        if _VERSION == \"Lua 5.1\" then\n"
"            setfenv(f , env);\n"
"        else\n"
"            debug.setupvalue(f, 1, env);\n"
"        end\n"
"        xpcall(function() retString = f() end , function() retString = \"输入了错误的变量信息\"; var.isSuccess = \"false\"; end)\n"
"    else\n"
"        retString = \"未能找到变量的值\";\n"
"        var.isSuccess = \"false\";\n"
"    end\n"
"\n"
"    var.name = msgTable.varName;\n"
"    var.type = tostring(type(retString));\n"
"    xpcall(function() var.value = tostring(retString) end , function() var.value = tostring(type(retString)) .. \" [value can't trans to string]\"; var.isSuccess = \"false\"; end );\n"
"    var.variablesReference = \"0\";\n"
"\n"
"    if var.type == \"table\" or var.type == \"function\" then\n"
"        variableRefTab[variableRefIdx] = retString;\n"
"        var.variablesReference = variableRefIdx;\n"
"        variableRefIdx = variableRefIdx + 1;\n"
"        if var.type == \"table\" then\n"
"            local memberNum = this.getTableMemberNum(retString);\n"
"            var.value = memberNum ..\" Members \".. var.value;\n"
"        end\n"
"    elseif var.type == \"string\" then\n"
"        var.value = '\"' ..retString.. '\"';\n"
"    end\n"
"\n"
"    local retTab = {}\n"
"    table.insert(retTab ,var);\n"
"    return retTab;\n"
"end\n"
"\n"
"this.printToConsole(\"load LuaPanda success\", 1);\n"
"return this;\n";

int luaopen_DebugTools(lua_State *L)
{
    luaL_loadstring(L, DebugTools);
    return 1;
}

int luaopen_LuaPanda(lua_State *L)
{
    luaL_loadstring(L, LuaPanda);
    return 1;
}
