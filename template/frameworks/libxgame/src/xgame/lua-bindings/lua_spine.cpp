//
// generated by olua
//
#include "xgame/lua-bindings/lua_cocos2d_ui.h"
#include "xgame/lua-bindings/lua_conv.h"
#include "xgame/lua-bindings/lua_conv_manual.h"
#include "xgame/xlua.h"
#include "xgame/xruntime.h"
#include "olua/olua.hpp"
#include "cocos2d.h"
#include "spine/spine-cocos2dx.h"



static int luaopen_spEventType(lua_State *L)
{
    oluacls_class(L, "sp.EventType", nullptr);
    oluacls_const_integer(L, "ANIMATION_START", (lua_Integer)spEventType::SP_ANIMATION_START);
    oluacls_const_integer(L, "ANIMATION_INTERRUPT", (lua_Integer)spEventType::SP_ANIMATION_INTERRUPT);
    oluacls_const_integer(L, "ANIMATION_END", (lua_Integer)spEventType::SP_ANIMATION_END);
    oluacls_const_integer(L, "ANIMATION_COMPLETE", (lua_Integer)spEventType::SP_ANIMATION_COMPLETE);
    oluacls_const_integer(L, "ANIMATION_DISPOSE", (lua_Integer)spEventType::SP_ANIMATION_DISPOSE);
    oluacls_const_integer(L, "ANIMATION_EVENT", (lua_Integer)spEventType::SP_ANIMATION_EVENT);

    olua_registerluatype<spEventType>(L, "sp.EventType");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spAttachmentType(lua_State *L)
{
    oluacls_class(L, "sp.AttachmentType", nullptr);
    oluacls_const_integer(L, "ATTACHMENT_REGION", (lua_Integer)spAttachmentType::SP_ATTACHMENT_REGION);
    oluacls_const_integer(L, "ATTACHMENT_BOUNDING_BOX", (lua_Integer)spAttachmentType::SP_ATTACHMENT_BOUNDING_BOX);
    oluacls_const_integer(L, "ATTACHMENT_MESH", (lua_Integer)spAttachmentType::SP_ATTACHMENT_MESH);
    oluacls_const_integer(L, "ATTACHMENT_LINKED_MESH", (lua_Integer)spAttachmentType::SP_ATTACHMENT_LINKED_MESH);
    oluacls_const_integer(L, "ATTACHMENT_PATH", (lua_Integer)spAttachmentType::SP_ATTACHMENT_PATH);
    oluacls_const_integer(L, "ATTACHMENT_POINT", (lua_Integer)spAttachmentType::SP_ATTACHMENT_POINT);
    oluacls_const_integer(L, "ATTACHMENT_CLIPPING", (lua_Integer)spAttachmentType::SP_ATTACHMENT_CLIPPING);

    olua_registerluatype<spAttachmentType>(L, "sp.AttachmentType");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spTrackEntry_get_animation(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    spAnimation *ret = (spAnimation *)self->animation;
    int num_ret = olua_push_obj(L, ret, "sp.Animation");

    return num_ret;
}

static int _spTrackEntry_get_next(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    spTrackEntry *ret = (spTrackEntry *)self->next;
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spTrackEntry_get_mixingFrom(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    spTrackEntry *ret = (spTrackEntry *)self->mixingFrom;
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spTrackEntry_get_trackIndex(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    int ret = (int)self->trackIndex;
    int num_ret = olua_push_int(L, (lua_Integer)ret);

    return num_ret;
}

static int _spTrackEntry_get_loop(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    int ret = (int)self->loop;
    int num_ret = olua_push_int(L, (lua_Integer)ret);

    return num_ret;
}

static int _spTrackEntry_get_eventThreshold(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->eventThreshold;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_attachmentThreshold(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->attachmentThreshold;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_drawOrderThreshold(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->drawOrderThreshold;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_animationStart(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->animationStart;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_animationEnd(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->animationEnd;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_animationLast(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->animationLast;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_nextAnimationLast(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->nextAnimationLast;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_delay(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->delay;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_trackTime(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->trackTime;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_trackLast(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->trackLast;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_nextTrackLast(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->nextTrackLast;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_trackEnd(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->trackEnd;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_timeScale(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->timeScale;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_alpha(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->alpha;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_mixTime(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->mixTime;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_mixDuration(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->mixDuration;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_interruptAlpha(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->interruptAlpha;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spTrackEntry_get_totalAlpha(lua_State *L)
{
    lua_settop(L, 1);

    spTrackEntry *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.TrackEntry");

    // <function var>
    float ret = (float)self->totalAlpha;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int luaopen_spTrackEntry(lua_State *L)
{
    oluacls_class(L, "sp.TrackEntry", nullptr);
    oluacls_property(L, "animation", _spTrackEntry_get_animation, nullptr);
    oluacls_property(L, "next", _spTrackEntry_get_next, nullptr);
    oluacls_property(L, "mixingFrom", _spTrackEntry_get_mixingFrom, nullptr);
    oluacls_property(L, "trackIndex", _spTrackEntry_get_trackIndex, nullptr);
    oluacls_property(L, "loop", _spTrackEntry_get_loop, nullptr);
    oluacls_property(L, "eventThreshold", _spTrackEntry_get_eventThreshold, nullptr);
    oluacls_property(L, "attachmentThreshold", _spTrackEntry_get_attachmentThreshold, nullptr);
    oluacls_property(L, "drawOrderThreshold", _spTrackEntry_get_drawOrderThreshold, nullptr);
    oluacls_property(L, "animationStart", _spTrackEntry_get_animationStart, nullptr);
    oluacls_property(L, "animationEnd", _spTrackEntry_get_animationEnd, nullptr);
    oluacls_property(L, "animationLast", _spTrackEntry_get_animationLast, nullptr);
    oluacls_property(L, "nextAnimationLast", _spTrackEntry_get_nextAnimationLast, nullptr);
    oluacls_property(L, "delay", _spTrackEntry_get_delay, nullptr);
    oluacls_property(L, "trackTime", _spTrackEntry_get_trackTime, nullptr);
    oluacls_property(L, "trackLast", _spTrackEntry_get_trackLast, nullptr);
    oluacls_property(L, "nextTrackLast", _spTrackEntry_get_nextTrackLast, nullptr);
    oluacls_property(L, "trackEnd", _spTrackEntry_get_trackEnd, nullptr);
    oluacls_property(L, "timeScale", _spTrackEntry_get_timeScale, nullptr);
    oluacls_property(L, "alpha", _spTrackEntry_get_alpha, nullptr);
    oluacls_property(L, "mixTime", _spTrackEntry_get_mixTime, nullptr);
    oluacls_property(L, "mixDuration", _spTrackEntry_get_mixDuration, nullptr);
    oluacls_property(L, "interruptAlpha", _spTrackEntry_get_interruptAlpha, nullptr);
    oluacls_property(L, "totalAlpha", _spTrackEntry_get_totalAlpha, nullptr);

    olua_registerluatype<spTrackEntry>(L, "sp.TrackEntry");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spSkeletonData(lua_State *L)
{
    oluacls_class(L, "sp.SkeletonData", nullptr);

    olua_registerluatype<spSkeletonData>(L, "sp.SkeletonData");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spAnimation_get_name(lua_State *L)
{
    lua_settop(L, 1);

    spAnimation *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Animation");

    // <function var>
    const char *ret = (const char *)self->name;
    int num_ret = olua_push_string(L, ret);

    return num_ret;
}

static int _spAnimation_get_duration(lua_State *L)
{
    lua_settop(L, 1);

    spAnimation *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Animation");

    // <function var>
    float ret = (float)self->duration;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int luaopen_spAnimation(lua_State *L)
{
    oluacls_class(L, "sp.Animation", nullptr);
    oluacls_property(L, "name", _spAnimation_get_name, nullptr);
    oluacls_property(L, "duration", _spAnimation_get_duration, nullptr);

    olua_registerluatype<spAnimation>(L, "sp.Animation");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spAtlas(lua_State *L)
{
    oluacls_class(L, "sp.Atlas", nullptr);

    olua_registerluatype<spAtlas>(L, "sp.Atlas");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spEvent_get_data(lua_State *L)
{
    lua_settop(L, 1);

    spEvent *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Event");

    // <function var>
    spEventData *ret = (spEventData *)self->data;
    int num_ret = olua_push_obj(L, ret, "sp.EventData");

    return num_ret;
}

static int _spEvent_get_time(lua_State *L)
{
    lua_settop(L, 1);

    spEvent *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Event");

    // <function var>
    float ret = (float)self->time;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spEvent_get_intValue(lua_State *L)
{
    lua_settop(L, 1);

    spEvent *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Event");

    // <function var>
    int ret = (int)self->intValue;
    int num_ret = olua_push_int(L, (lua_Integer)ret);

    return num_ret;
}

static int _spEvent_get_floatValue(lua_State *L)
{
    lua_settop(L, 1);

    spEvent *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Event");

    // <function var>
    float ret = (float)self->floatValue;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spEvent_get_stringValue(lua_State *L)
{
    lua_settop(L, 1);

    spEvent *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Event");

    // <function var>
    const char *ret = (const char *)self->stringValue;
    int num_ret = olua_push_string(L, ret);

    return num_ret;
}

static int luaopen_spEvent(lua_State *L)
{
    oluacls_class(L, "sp.Event", nullptr);
    oluacls_property(L, "data", _spEvent_get_data, nullptr);
    oluacls_property(L, "time", _spEvent_get_time, nullptr);
    oluacls_property(L, "intValue", _spEvent_get_intValue, nullptr);
    oluacls_property(L, "floatValue", _spEvent_get_floatValue, nullptr);
    oluacls_property(L, "stringValue", _spEvent_get_stringValue, nullptr);

    olua_registerluatype<spEvent>(L, "sp.Event");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spEventData_get_name(lua_State *L)
{
    lua_settop(L, 1);

    spEventData *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.EventData");

    // <function var>
    const char *ret = (const char *)self->name;
    int num_ret = olua_push_string(L, ret);

    return num_ret;
}

static int _spEventData_get_intValue(lua_State *L)
{
    lua_settop(L, 1);

    spEventData *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.EventData");

    // <function var>
    int ret = (int)self->intValue;
    int num_ret = olua_push_int(L, (lua_Integer)ret);

    return num_ret;
}

static int _spEventData_get_floatValue(lua_State *L)
{
    lua_settop(L, 1);

    spEventData *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.EventData");

    // <function var>
    float ret = (float)self->floatValue;
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spEventData_get_stringValue(lua_State *L)
{
    lua_settop(L, 1);

    spEventData *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.EventData");

    // <function var>
    const char *ret = (const char *)self->stringValue;
    int num_ret = olua_push_string(L, ret);

    return num_ret;
}

static int luaopen_spEventData(lua_State *L)
{
    oluacls_class(L, "sp.EventData", nullptr);
    oluacls_property(L, "name", _spEventData_get_name, nullptr);
    oluacls_property(L, "intValue", _spEventData_get_intValue, nullptr);
    oluacls_property(L, "floatValue", _spEventData_get_floatValue, nullptr);
    oluacls_property(L, "stringValue", _spEventData_get_stringValue, nullptr);

    olua_registerluatype<spEventData>(L, "sp.EventData");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spAnimationState(lua_State *L)
{
    oluacls_class(L, "sp.AnimationState", nullptr);

    olua_registerluatype<spAnimationState>(L, "sp.AnimationState");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spSkeleton(lua_State *L)
{
    oluacls_class(L, "sp.Skeleton", nullptr);

    olua_registerluatype<spSkeleton>(L, "sp.Skeleton");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spBone(lua_State *L)
{
    oluacls_class(L, "sp.Bone", nullptr);

    olua_registerluatype<spBone>(L, "sp.Bone");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spSlot(lua_State *L)
{
    oluacls_class(L, "sp.Slot", nullptr);

    olua_registerluatype<spSlot>(L, "sp.Slot");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spAttachment_get_name(lua_State *L)
{
    lua_settop(L, 1);

    spAttachment *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Attachment");

    // <function var>
    const char *ret = (const char *)self->name;
    int num_ret = olua_push_string(L, ret);

    return num_ret;
}

static int _spAttachment_get_type(lua_State *L)
{
    lua_settop(L, 1);

    spAttachment *self = nullptr;

    olua_to_obj(L, 1, (void **)&self, "sp.Attachment");

    // <function var>
    const spAttachmentType ret = (const spAttachmentType)self->type;
    int num_ret = olua_push_uint(L, (lua_Unsigned)ret);

    return num_ret;
}

static int luaopen_spAttachment(lua_State *L)
{
    oluacls_class(L, "sp.Attachment", nullptr);
    oluacls_property(L, "name", _spAttachment_get_name, nullptr);
    oluacls_property(L, "type", _spAttachment_get_type, nullptr);

    olua_registerluatype<spAttachment>(L, "sp.Attachment");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spVertexEffect(lua_State *L)
{
    oluacls_class(L, "sp.VertexEffect", nullptr);

    olua_registerluatype<spVertexEffect>(L, "sp.VertexEffect");
    oluacls_createclassproxy(L);

    return 1;
}

static int luaopen_spAnimationStateData(lua_State *L)
{
    oluacls_class(L, "sp.AnimationStateData", nullptr);

    olua_registerluatype<spAnimationStateData>(L, "sp.AnimationStateData");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spine_SkeletonRenderer_create(lua_State *L)
{
    lua_settop(L, 0);

    // static SkeletonRenderer* create()
    spine::SkeletonRenderer *ret = (spine::SkeletonRenderer *)spine::SkeletonRenderer::create();
    int num_ret = olua_push_cppobj<spine::SkeletonRenderer>(L, ret, "sp.SkeletonRenderer");

    return num_ret;
}

static int _spine_SkeletonRenderer_createWithData(lua_State *L)
{
    lua_settop(L, 2);

    spSkeletonData *arg1 = nullptr;   /** skeletonData */
    bool arg2 = false;   /** ownsSkeletonData */

    olua_check_obj(L, 1, (void **)&arg1, "sp.SkeletonData");
    olua_opt_bool(L, 2, &arg2, (bool)false);

    // static SkeletonRenderer* createWithData (spSkeletonData* skeletonData, bool ownsSkeletonData = false)
    spine::SkeletonRenderer *ret = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithData(arg1, arg2);
    int num_ret = olua_push_cppobj<spine::SkeletonRenderer>(L, ret, "sp.SkeletonRenderer");

    return num_ret;
}

static int _spine_SkeletonRenderer_createWithFile1(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonDataFile */
    spAtlas *arg2 = nullptr;   /** atlas */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_obj(L, 2, (void **)&arg2, "sp.Atlas");
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonRenderer* createWithFile (const std::string& skeletonDataFile, spAtlas* atlas, float scale = 1)
    spine::SkeletonRenderer *ret = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonRenderer>(L, ret, "sp.SkeletonRenderer");

    return num_ret;
}

static int _spine_SkeletonRenderer_createWithFile2(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonDataFile */
    std::string arg2;       /** atlasFile */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_std_string(L, 2, &arg2);
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonRenderer* createWithFile (const std::string& skeletonDataFile, const std::string& atlasFile, float scale = 1)
    spine::SkeletonRenderer *ret = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonRenderer>(L, ret, "sp.SkeletonRenderer");

    return num_ret;
}

static int _spine_SkeletonRenderer_createWithFile(lua_State *L)
{
    int num_args = lua_gettop(L);

    if (num_args == 3) {
        if (olua_is_std_string(L, 1) && olua_is_obj(L, 2, "sp.Atlas") && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonRenderer_createWithFile1(L);
        }

        // if (olua_is_std_string(L, 1) && olua_is_std_string(L, 2) && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonRenderer_createWithFile2(L);
        // }
    }

    luaL_error(L, "method 'spine::SkeletonRenderer::createWithFile' not support '%d' arguments", num_args);

    return 0;
}

static int _spine_SkeletonRenderer_drawDebug(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonRenderer *self = nullptr;
    cocos2d::Renderer *arg1 = nullptr;   /** renderer */
    cocos2d::Mat4 arg2;       /** transform */
    lua_Unsigned arg3 = 0;   /** transformFlags */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_cppobj(L, 2, (void **)&arg1, "cc.Renderer");
    manual_luacv_check_cocos2d_Mat4(L, 3, &arg2);
    olua_check_uint(L, 4, &arg3);

    // void drawDebug (cocos2d::Renderer* renderer, const cocos2d::Mat4& transform, uint32_t transformFlags)
    self->drawDebug(arg1, arg2, (uint32_t)arg3);

    return 0;
}

static int _spine_SkeletonRenderer_getSkeleton(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // spSkeleton* getSkeleton()
    spSkeleton *ret = (spSkeleton *)self->getSkeleton();
    int num_ret = olua_push_obj(L, ret, "sp.Skeleton");

    return num_ret;
}

static int _spine_SkeletonRenderer_setTimeScale(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    lua_Number arg1 = 0;   /** scale */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_number(L, 2, &arg1);

    // void setTimeScale(float scale)
    self->setTimeScale((float)arg1);

    return 0;
}

static int _spine_SkeletonRenderer_getTimeScale(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // float getTimeScale()
    float ret = (float)self->getTimeScale();
    int num_ret = olua_push_number(L, (lua_Number)ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setDebugSlotsEnabled(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    bool arg1 = false;   /** enabled */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_bool(L, 2, &arg1);

    // void setDebugSlotsEnabled(bool enabled)
    self->setDebugSlotsEnabled(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_getDebugSlotsEnabled(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // bool getDebugSlotsEnabled()
    bool ret = (bool)self->getDebugSlotsEnabled();
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setDebugBonesEnabled(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    bool arg1 = false;   /** enabled */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_bool(L, 2, &arg1);

    // void setDebugBonesEnabled(bool enabled)
    self->setDebugBonesEnabled(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_getDebugBonesEnabled(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // bool getDebugBonesEnabled()
    bool ret = (bool)self->getDebugBonesEnabled();
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setDebugMeshesEnabled(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    bool arg1 = false;   /** enabled */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_bool(L, 2, &arg1);

    // void setDebugMeshesEnabled(bool enabled)
    self->setDebugMeshesEnabled(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_getDebugMeshesEnabled(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // bool getDebugMeshesEnabled()
    bool ret = (bool)self->getDebugMeshesEnabled();
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_updateWorldTransform(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // void updateWorldTransform ()
    self->updateWorldTransform();

    return 0;
}

static int _spine_SkeletonRenderer_setToSetupPose(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // void setToSetupPose ()
    self->setToSetupPose();

    return 0;
}

static int _spine_SkeletonRenderer_setBonesToSetupPose(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // void setBonesToSetupPose ()
    self->setBonesToSetupPose();

    return 0;
}

static int _spine_SkeletonRenderer_setSlotsToSetupPose(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // void setSlotsToSetupPose ()
    self->setSlotsToSetupPose();

    return 0;
}

static int _spine_SkeletonRenderer_findBone(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** boneName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);

    // spBone* findBone (const std::string& boneName)
    spBone *ret = (spBone *)self->findBone(arg1);
    int num_ret = olua_push_obj(L, ret, "sp.Bone");

    return num_ret;
}

static int _spine_SkeletonRenderer_findSlot(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** slotName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);

    // spSlot* findSlot (const std::string& slotName)
    spSlot *ret = (spSlot *)self->findSlot(arg1);
    int num_ret = olua_push_obj(L, ret, "sp.Slot");

    return num_ret;
}

static int _spine_SkeletonRenderer_setSkin1(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** skinName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);

    // bool setSkin (const std::string& skinName)
    bool ret = (bool)self->setSkin(arg1);
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setSkin2(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    const char *arg1 = nullptr;   /** skinName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_string(L, 2, &arg1);

    // bool setSkin (const char* skinName)
    bool ret = (bool)self->setSkin(arg1);
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setSkin(lua_State *L)
{
    int num_args = lua_gettop(L) - 1;

    if (num_args == 1) {
        if (olua_is_std_string(L, 2)) {
            return _spine_SkeletonRenderer_setSkin1(L);
        }

        // if (olua_is_string(L, 2)) {
            return _spine_SkeletonRenderer_setSkin2(L);
        // }
    }

    luaL_error(L, "method 'spine::SkeletonRenderer::setSkin' not support '%d' arguments", num_args);

    return 0;
}

static int _spine_SkeletonRenderer_getAttachment(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** slotName */
    std::string arg2;       /** attachmentName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);
    olua_check_std_string(L, 3, &arg2);

    // spAttachment* getAttachment (const std::string& slotName, const std::string& attachmentName)
    spAttachment *ret = (spAttachment *)self->getAttachment(arg1, arg2);
    int num_ret = olua_push_obj(L, ret, "sp.Attachment");

    return num_ret;
}

static int _spine_SkeletonRenderer_setAttachment1(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** slotName */
    std::string arg2;       /** attachmentName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);
    olua_check_std_string(L, 3, &arg2);

    // bool setAttachment (const std::string& slotName, const std::string& attachmentName)
    bool ret = (bool)self->setAttachment(arg1, arg2);
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setAttachment2(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonRenderer *self = nullptr;
    std::string arg1;       /** slotName */
    const char *arg2 = nullptr;   /** attachmentName */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_std_string(L, 2, &arg1);
    olua_check_string(L, 3, &arg2);

    // bool setAttachment (const std::string& slotName, const char* attachmentName)
    bool ret = (bool)self->setAttachment(arg1, arg2);
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setAttachment(lua_State *L)
{
    int num_args = lua_gettop(L) - 1;

    if (num_args == 2) {
        if (olua_is_std_string(L, 2) && olua_is_std_string(L, 3)) {
            return _spine_SkeletonRenderer_setAttachment1(L);
        }

        // if (olua_is_std_string(L, 2) && olua_is_string(L, 3)) {
            return _spine_SkeletonRenderer_setAttachment2(L);
        // }
    }

    luaL_error(L, "method 'spine::SkeletonRenderer::setAttachment' not support '%d' arguments", num_args);

    return 0;
}

static int _spine_SkeletonRenderer_setTwoColorTint(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    bool arg1 = false;   /** enabled */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_bool(L, 2, &arg1);

    // void setTwoColorTint(bool enabled)
    self->setTwoColorTint(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_isTwoColorTint(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // bool isTwoColorTint()
    bool ret = (bool)self->isTwoColorTint();
    int num_ret = olua_push_bool(L, ret);

    return num_ret;
}

static int _spine_SkeletonRenderer_setVertexEffect(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    spVertexEffect *arg1 = nullptr;   /** effect */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    olua_check_obj(L, 2, (void **)&arg1, "sp.VertexEffect");

    // void setVertexEffect(spVertexEffect* effect)
    self->setVertexEffect(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_setBlendFunc(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonRenderer *self = nullptr;
    cocos2d::BlendFunc arg1;       /** blendFunc */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");
    auto_luacv_check_cocos2d_BlendFunc(L, 2, &arg1);

    // void setBlendFunc (const cocos2d::BlendFunc& blendFunc)
    self->setBlendFunc(arg1);

    return 0;
}

static int _spine_SkeletonRenderer_getBlendFunc(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonRenderer *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonRenderer");

    // const cocos2d::BlendFunc& getBlendFunc ()
    const cocos2d::BlendFunc &ret = (const cocos2d::BlendFunc &)self->getBlendFunc();
    int num_ret = auto_luacv_push_cocos2d_BlendFunc(L, &ret);

    return num_ret;
}

static int luaopen_spine_SkeletonRenderer(lua_State *L)
{
    oluacls_class(L, "sp.SkeletonRenderer", "cc.Node");
    oluacls_setfunc(L, "create", _spine_SkeletonRenderer_create);
    oluacls_setfunc(L, "createWithData", _spine_SkeletonRenderer_createWithData);
    oluacls_setfunc(L, "createWithFile", _spine_SkeletonRenderer_createWithFile);
    oluacls_setfunc(L, "drawDebug", _spine_SkeletonRenderer_drawDebug);
    oluacls_setfunc(L, "getSkeleton", _spine_SkeletonRenderer_getSkeleton);
    oluacls_setfunc(L, "setTimeScale", _spine_SkeletonRenderer_setTimeScale);
    oluacls_setfunc(L, "getTimeScale", _spine_SkeletonRenderer_getTimeScale);
    oluacls_setfunc(L, "setDebugSlotsEnabled", _spine_SkeletonRenderer_setDebugSlotsEnabled);
    oluacls_setfunc(L, "getDebugSlotsEnabled", _spine_SkeletonRenderer_getDebugSlotsEnabled);
    oluacls_setfunc(L, "setDebugBonesEnabled", _spine_SkeletonRenderer_setDebugBonesEnabled);
    oluacls_setfunc(L, "getDebugBonesEnabled", _spine_SkeletonRenderer_getDebugBonesEnabled);
    oluacls_setfunc(L, "setDebugMeshesEnabled", _spine_SkeletonRenderer_setDebugMeshesEnabled);
    oluacls_setfunc(L, "getDebugMeshesEnabled", _spine_SkeletonRenderer_getDebugMeshesEnabled);
    oluacls_setfunc(L, "updateWorldTransform", _spine_SkeletonRenderer_updateWorldTransform);
    oluacls_setfunc(L, "setToSetupPose", _spine_SkeletonRenderer_setToSetupPose);
    oluacls_setfunc(L, "setBonesToSetupPose", _spine_SkeletonRenderer_setBonesToSetupPose);
    oluacls_setfunc(L, "setSlotsToSetupPose", _spine_SkeletonRenderer_setSlotsToSetupPose);
    oluacls_setfunc(L, "findBone", _spine_SkeletonRenderer_findBone);
    oluacls_setfunc(L, "findSlot", _spine_SkeletonRenderer_findSlot);
    oluacls_setfunc(L, "setSkin", _spine_SkeletonRenderer_setSkin);
    oluacls_setfunc(L, "getAttachment", _spine_SkeletonRenderer_getAttachment);
    oluacls_setfunc(L, "setAttachment", _spine_SkeletonRenderer_setAttachment);
    oluacls_setfunc(L, "setTwoColorTint", _spine_SkeletonRenderer_setTwoColorTint);
    oluacls_setfunc(L, "isTwoColorTint", _spine_SkeletonRenderer_isTwoColorTint);
    oluacls_setfunc(L, "setVertexEffect", _spine_SkeletonRenderer_setVertexEffect);
    oluacls_setfunc(L, "setBlendFunc", _spine_SkeletonRenderer_setBlendFunc);
    oluacls_setfunc(L, "getBlendFunc", _spine_SkeletonRenderer_getBlendFunc);

    olua_registerluatype<spine::SkeletonRenderer>(L, "sp.SkeletonRenderer");
    oluacls_createclassproxy(L);

    return 1;
}

static int _spine_SkeletonAnimation_createWithData(lua_State *L)
{
    lua_settop(L, 2);

    spSkeletonData *arg1 = nullptr;   /** skeletonData */
    bool arg2 = false;   /** ownsSkeletonData */

    olua_check_obj(L, 1, (void **)&arg1, "sp.SkeletonData");
    olua_opt_bool(L, 2, &arg2, (bool)false);

    // static SkeletonAnimation* createWithData (spSkeletonData* skeletonData, bool ownsSkeletonData = false)
    spine::SkeletonAnimation *ret = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithData(arg1, arg2);
    int num_ret = olua_push_cppobj<spine::SkeletonAnimation>(L, ret, "sp.SkeletonAnimation");

    return num_ret;
}

static int _spine_SkeletonAnimation_createWithJsonFile1(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonJsonFile */
    spAtlas *arg2 = nullptr;   /** atlas */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_obj(L, 2, (void **)&arg2, "sp.Atlas");
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonAnimation* createWithJsonFile (const std::string& skeletonJsonFile, spAtlas* atlas, float scale = 1)
    spine::SkeletonAnimation *ret = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonAnimation>(L, ret, "sp.SkeletonAnimation");

    return num_ret;
}

static int _spine_SkeletonAnimation_createWithJsonFile2(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonJsonFile */
    std::string arg2;       /** atlasFile */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_std_string(L, 2, &arg2);
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonAnimation* createWithJsonFile (const std::string& skeletonJsonFile, const std::string& atlasFile, float scale = 1)
    spine::SkeletonAnimation *ret = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonAnimation>(L, ret, "sp.SkeletonAnimation");

    return num_ret;
}

static int _spine_SkeletonAnimation_createWithJsonFile(lua_State *L)
{
    int num_args = lua_gettop(L);

    if (num_args == 3) {
        if (olua_is_std_string(L, 1) && olua_is_obj(L, 2, "sp.Atlas") && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonAnimation_createWithJsonFile1(L);
        }

        // if (olua_is_std_string(L, 1) && olua_is_std_string(L, 2) && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonAnimation_createWithJsonFile2(L);
        // }
    }

    luaL_error(L, "method 'spine::SkeletonAnimation::createWithJsonFile' not support '%d' arguments", num_args);

    return 0;
}

static int _spine_SkeletonAnimation_createWithBinaryFile1(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonBinaryFile */
    spAtlas *arg2 = nullptr;   /** atlas */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_obj(L, 2, (void **)&arg2, "sp.Atlas");
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonAnimation* createWithBinaryFile (const std::string& skeletonBinaryFile, spAtlas* atlas, float scale = 1)
    spine::SkeletonAnimation *ret = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonAnimation>(L, ret, "sp.SkeletonAnimation");

    return num_ret;
}

static int _spine_SkeletonAnimation_createWithBinaryFile2(lua_State *L)
{
    lua_settop(L, 3);

    std::string arg1;       /** skeletonBinaryFile */
    std::string arg2;       /** atlasFile */
    lua_Number arg3 = 0;   /** scale */

    olua_check_std_string(L, 1, &arg1);
    olua_check_std_string(L, 2, &arg2);
    olua_opt_number(L, 3, &arg3, (lua_Number)1);

    // static SkeletonAnimation* createWithBinaryFile (const std::string& skeletonBinaryFile, const std::string& atlasFile, float scale = 1)
    spine::SkeletonAnimation *ret = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile(arg1, arg2, (float)arg3);
    int num_ret = olua_push_cppobj<spine::SkeletonAnimation>(L, ret, "sp.SkeletonAnimation");

    return num_ret;
}

static int _spine_SkeletonAnimation_createWithBinaryFile(lua_State *L)
{
    int num_args = lua_gettop(L);

    if (num_args == 3) {
        if (olua_is_std_string(L, 1) && olua_is_obj(L, 2, "sp.Atlas") && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonAnimation_createWithBinaryFile1(L);
        }

        // if (olua_is_std_string(L, 1) && olua_is_std_string(L, 2) && (olua_is_number(L, 3) || olua_isnil(L, 3))) {
            return _spine_SkeletonAnimation_createWithBinaryFile2(L);
        // }
    }

    luaL_error(L, "method 'spine::SkeletonAnimation::createWithBinaryFile' not support '%d' arguments", num_args);

    return 0;
}

static int _spine_SkeletonAnimation_setAnimationStateData(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    spAnimationStateData *arg1 = nullptr;   /** stateData */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.AnimationStateData");

    // void setAnimationStateData (spAnimationStateData* stateData)
    self->setAnimationStateData(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setMix(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonAnimation *self = nullptr;
    std::string arg1;       /** fromAnimation */
    std::string arg2;       /** toAnimation */
    lua_Number arg3 = 0;   /** duration */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_std_string(L, 2, &arg1);
    olua_check_std_string(L, 3, &arg2);
    olua_check_number(L, 4, &arg3);

    // void setMix (const std::string& fromAnimation, const std::string& toAnimation, float duration)
    self->setMix(arg1, arg2, (float)arg3);

    return 0;
}

static int _spine_SkeletonAnimation_setAnimation(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */
    std::string arg2;       /** name */
    bool arg3 = false;   /** loop */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_int(L, 2, &arg1);
    olua_check_std_string(L, 3, &arg2);
    olua_check_bool(L, 4, &arg3);

    // spTrackEntry* setAnimation (int trackIndex, const std::string& name, bool loop)
    spTrackEntry *ret = (spTrackEntry *)self->setAnimation((int)arg1, arg2, arg3);
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spine_SkeletonAnimation_addAnimation(lua_State *L)
{
    lua_settop(L, 5);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */
    std::string arg2;       /** name */
    bool arg3 = false;   /** loop */
    lua_Number arg4 = 0;   /** delay */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_int(L, 2, &arg1);
    olua_check_std_string(L, 3, &arg2);
    olua_check_bool(L, 4, &arg3);
    olua_opt_number(L, 5, &arg4, (lua_Number)0);

    // spTrackEntry* addAnimation (int trackIndex, const std::string& name, bool loop, float delay = 0)
    spTrackEntry *ret = (spTrackEntry *)self->addAnimation((int)arg1, arg2, arg3, (float)arg4);
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spine_SkeletonAnimation_setEmptyAnimation(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */
    lua_Number arg2 = 0;   /** mixDuration */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_int(L, 2, &arg1);
    olua_check_number(L, 3, &arg2);

    // spTrackEntry* setEmptyAnimation (int trackIndex, float mixDuration)
    spTrackEntry *ret = (spTrackEntry *)self->setEmptyAnimation((int)arg1, (float)arg2);
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spine_SkeletonAnimation_setEmptyAnimations(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    lua_Number arg1 = 0;   /** mixDuration */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_number(L, 2, &arg1);

    // void setEmptyAnimations (float mixDuration)
    self->setEmptyAnimations((float)arg1);

    return 0;
}

static int _spine_SkeletonAnimation_addEmptyAnimation(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */
    lua_Number arg2 = 0;   /** mixDuration */
    lua_Number arg3 = 0;   /** delay */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_int(L, 2, &arg1);
    olua_check_number(L, 3, &arg2);
    olua_opt_number(L, 4, &arg3, (lua_Number)0);

    // spTrackEntry* addEmptyAnimation (int trackIndex, float mixDuration, float delay = 0)
    spTrackEntry *ret = (spTrackEntry *)self->addEmptyAnimation((int)arg1, (float)arg2, (float)arg3);
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spine_SkeletonAnimation_findAnimation(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::string arg1;       /** name */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_std_string(L, 2, &arg1);

    // spAnimation* findAnimation(const std::string& name)
    spAnimation *ret = (spAnimation *)self->findAnimation(arg1);
    int num_ret = olua_push_obj(L, ret, "sp.Animation");

    return num_ret;
}

static int _spine_SkeletonAnimation_getCurrent(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_opt_int(L, 2, &arg1, (lua_Integer)0);

    // spTrackEntry* getCurrent (int trackIndex = 0)
    spTrackEntry *ret = (spTrackEntry *)self->getCurrent((int)arg1);
    int num_ret = olua_push_obj(L, ret, "sp.TrackEntry");

    return num_ret;
}

static int _spine_SkeletonAnimation_clearTracks(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonAnimation *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    // void clearTracks ()
    self->clearTracks();

    return 0;
}

static int _spine_SkeletonAnimation_clearTrack(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    lua_Integer arg1 = 0;   /** trackIndex */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_opt_int(L, 2, &arg1, (lua_Integer)0);

    // void clearTrack (int trackIndex = 0)
    self->clearTrack((int)arg1);

    return 0;
}

static int _spine_SkeletonAnimation_onAnimationStateEvent(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    lua_Unsigned arg2 = 0;   /** type */
    spEvent *arg3 = nullptr;   /** event */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");
    olua_check_uint(L, 3, &arg2);
    olua_check_obj(L, 4, (void **)&arg3, "sp.Event");

    // void onAnimationStateEvent (spTrackEntry* entry, spEventType type, spEvent* event)
    self->onAnimationStateEvent(arg1, (spEventType)arg2, arg3);

    return 0;
}

static int _spine_SkeletonAnimation_onTrackEntryEvent(lua_State *L)
{
    lua_settop(L, 4);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    lua_Unsigned arg2 = 0;   /** type */
    spEvent *arg3 = nullptr;   /** event */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");
    olua_check_uint(L, 3, &arg2);
    olua_check_obj(L, 4, (void **)&arg3, "sp.Event");

    // void onTrackEntryEvent (spTrackEntry* entry, spEventType type, spEvent* event)
    self->onTrackEntryEvent(arg1, (spEventType)arg2, arg3);

    return 0;
}

static int _spine_SkeletonAnimation_getState(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonAnimation *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    // spAnimationState* getState()
    spAnimationState *ret = (spAnimationState *)self->getState();
    int num_ret = olua_push_obj(L, ret, "sp.AnimationState");

    return num_ret;
}

static int _spine_SkeletonAnimation_initialize(lua_State *L)
{
    lua_settop(L, 1);

    spine::SkeletonAnimation *self = nullptr;

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    // void initialize ()
    self->initialize();

    return 0;
}

static int _spine_SkeletonAnimation_setStartListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("StartListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("StartListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setStartListener (@nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setStartListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setInterruptListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("InterruptListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("InterruptListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setInterruptListener (@nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setInterruptListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setEndListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("EndListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("EndListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setEndListener (@nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setEndListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setDisposeListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("DisposeListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("DisposeListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setDisposeListener (@nullable const std::function<void(spTrackEntry* entry)> listener)
    self->setDisposeListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setCompleteListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("CompleteListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("CompleteListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setCompleteListener (@nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setCompleteListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setEventListener(lua_State *L)
{
    lua_settop(L, 2);

    spine::SkeletonAnimation *self = nullptr;
    std::function<void(spTrackEntry *, spEvent *)> arg1 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");

    if (olua_is_std_function(L, 2)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("EventListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 2, OLUA_CALLBACK_TAG_REPLACE);
        arg1 = [callback_store_obj, func, tag](spTrackEntry *arg1, spEvent *arg2) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_push_obj(L, arg2, "sp.Event");
            olua_callback(L, callback_store_obj, func.c_str(), 2);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("EventListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg1 = nullptr;
    }

    // void setEventListener (@nullable const std::function<void(spTrackEntry* entry, spEvent* event)>& listener)
    self->setEventListener(arg1);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackStartListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackStartListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackStartListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackStartListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setTrackStartListener(arg1, arg2);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackInterruptListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackInterruptListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackInterruptListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackInterruptListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setTrackInterruptListener(arg1, arg2);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackEndListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackEndListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackEndListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackEndListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setTrackEndListener(arg1, arg2);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackDisposeListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackDisposeListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackDisposeListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackDisposeListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry)> listener)
    self->setTrackDisposeListener(arg1, arg2);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackCompleteListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackCompleteListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_callback(L, callback_store_obj, func.c_str(), 1);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackCompleteListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackCompleteListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry)>& listener)
    self->setTrackCompleteListener(arg1, arg2);

    return 0;
}

static int _spine_SkeletonAnimation_setTrackEventListener(lua_State *L)
{
    lua_settop(L, 3);

    spine::SkeletonAnimation *self = nullptr;
    spTrackEntry *arg1 = nullptr;   /** entry */
    std::function<void(spTrackEntry *, spEvent *)> arg2 = nullptr;   /** listener */

    olua_to_cppobj(L, 1, (void **)&self, "sp.SkeletonAnimation");
    olua_check_obj(L, 2, (void **)&arg1, "sp.TrackEntry");

    if (olua_is_std_function(L, 3)) {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackEventListener");
        std::string func = olua_setcallback(L, callback_store_obj, tag.c_str(), 3, OLUA_CALLBACK_TAG_REPLACE);
        arg2 = [callback_store_obj, func, tag](spTrackEntry *arg1, spEvent *arg2) {
            lua_State *L = olua_mainthread();
            int top = lua_gettop(L);

            olua_push_obj(L, arg1, "sp.TrackEntry");
            olua_push_obj(L, arg2, "sp.Event");
            olua_callback(L, callback_store_obj, func.c_str(), 2);

            lua_settop(L, top);
        };
    } else {
        void *callback_store_obj = (void *)self;
        std::string tag = olua_makecallbacktag("TrackEventListener");
        olua_removecallback(L, callback_store_obj, tag.c_str(), OLUA_CALLBACK_TAG_ENDWITH);
        arg2 = nullptr;
    }

    // void setTrackEventListener (spTrackEntry* entry, @nullable const std::function<void(spTrackEntry* entry, spEvent* event)>& listener)
    self->setTrackEventListener(arg1, arg2);

    return 0;
}

static int luaopen_spine_SkeletonAnimation(lua_State *L)
{
    oluacls_class(L, "sp.SkeletonAnimation", "sp.SkeletonRenderer");
    oluacls_setfunc(L, "createWithData", _spine_SkeletonAnimation_createWithData);
    oluacls_setfunc(L, "createWithJsonFile", _spine_SkeletonAnimation_createWithJsonFile);
    oluacls_setfunc(L, "createWithBinaryFile", _spine_SkeletonAnimation_createWithBinaryFile);
    oluacls_setfunc(L, "setAnimationStateData", _spine_SkeletonAnimation_setAnimationStateData);
    oluacls_setfunc(L, "setMix", _spine_SkeletonAnimation_setMix);
    oluacls_setfunc(L, "setAnimation", _spine_SkeletonAnimation_setAnimation);
    oluacls_setfunc(L, "addAnimation", _spine_SkeletonAnimation_addAnimation);
    oluacls_setfunc(L, "setEmptyAnimation", _spine_SkeletonAnimation_setEmptyAnimation);
    oluacls_setfunc(L, "setEmptyAnimations", _spine_SkeletonAnimation_setEmptyAnimations);
    oluacls_setfunc(L, "addEmptyAnimation", _spine_SkeletonAnimation_addEmptyAnimation);
    oluacls_setfunc(L, "findAnimation", _spine_SkeletonAnimation_findAnimation);
    oluacls_setfunc(L, "getCurrent", _spine_SkeletonAnimation_getCurrent);
    oluacls_setfunc(L, "clearTracks", _spine_SkeletonAnimation_clearTracks);
    oluacls_setfunc(L, "clearTrack", _spine_SkeletonAnimation_clearTrack);
    oluacls_setfunc(L, "onAnimationStateEvent", _spine_SkeletonAnimation_onAnimationStateEvent);
    oluacls_setfunc(L, "onTrackEntryEvent", _spine_SkeletonAnimation_onTrackEntryEvent);
    oluacls_setfunc(L, "getState", _spine_SkeletonAnimation_getState);
    oluacls_setfunc(L, "initialize", _spine_SkeletonAnimation_initialize);
    oluacls_setfunc(L, "setStartListener", _spine_SkeletonAnimation_setStartListener);
    oluacls_setfunc(L, "setInterruptListener", _spine_SkeletonAnimation_setInterruptListener);
    oluacls_setfunc(L, "setEndListener", _spine_SkeletonAnimation_setEndListener);
    oluacls_setfunc(L, "setDisposeListener", _spine_SkeletonAnimation_setDisposeListener);
    oluacls_setfunc(L, "setCompleteListener", _spine_SkeletonAnimation_setCompleteListener);
    oluacls_setfunc(L, "setEventListener", _spine_SkeletonAnimation_setEventListener);
    oluacls_setfunc(L, "setTrackStartListener", _spine_SkeletonAnimation_setTrackStartListener);
    oluacls_setfunc(L, "setTrackInterruptListener", _spine_SkeletonAnimation_setTrackInterruptListener);
    oluacls_setfunc(L, "setTrackEndListener", _spine_SkeletonAnimation_setTrackEndListener);
    oluacls_setfunc(L, "setTrackDisposeListener", _spine_SkeletonAnimation_setTrackDisposeListener);
    oluacls_setfunc(L, "setTrackCompleteListener", _spine_SkeletonAnimation_setTrackCompleteListener);
    oluacls_setfunc(L, "setTrackEventListener", _spine_SkeletonAnimation_setTrackEventListener);
    oluacls_property(L, "state", _spine_SkeletonAnimation_getState, nullptr);

    olua_registerluatype<spine::SkeletonAnimation>(L, "sp.SkeletonAnimation");
    oluacls_createclassproxy(L);

    return 1;
}

int luaopen_spine(lua_State *L)
{
    olua_require(L, "sp.EventType", luaopen_spEventType);
    olua_require(L, "sp.AttachmentType", luaopen_spAttachmentType);
    olua_require(L, "sp.TrackEntry", luaopen_spTrackEntry);
    olua_require(L, "sp.SkeletonData", luaopen_spSkeletonData);
    olua_require(L, "sp.Animation", luaopen_spAnimation);
    olua_require(L, "sp.Atlas", luaopen_spAtlas);
    olua_require(L, "sp.Event", luaopen_spEvent);
    olua_require(L, "sp.EventData", luaopen_spEventData);
    olua_require(L, "sp.AnimationState", luaopen_spAnimationState);
    olua_require(L, "sp.Skeleton", luaopen_spSkeleton);
    olua_require(L, "sp.Bone", luaopen_spBone);
    olua_require(L, "sp.Slot", luaopen_spSlot);
    olua_require(L, "sp.Attachment", luaopen_spAttachment);
    olua_require(L, "sp.VertexEffect", luaopen_spVertexEffect);
    olua_require(L, "sp.AnimationStateData", luaopen_spAnimationStateData);
    olua_require(L, "sp.SkeletonRenderer", luaopen_spine_SkeletonRenderer);
    olua_require(L, "sp.SkeletonAnimation", luaopen_spine_SkeletonAnimation);
    return 0;
}
